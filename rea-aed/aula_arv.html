 <!-- FlatFy Theme - Andrea Galanti /-->
<!doctype html>
<!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if IE 9]>    <html class="no-js ie9" lang="en"> <![endif]-->
<!--[if gt IE 9]><!--> <html> <!--<![endif]-->
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="description" content="Flatfy Free Flat and Responsive HTML5 Template ">
    <meta name="author" content="">

    <title>Aula - Árvores Binárias</title>

    <!-- Bootstrap core CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
 
    <!-- Custom Google Web Font -->
    <link href="font-awesome/css/font-awesome.min.css" rel="stylesheet">
    <link href='http://fonts.googleapis.com/css?family=Lato:100,300,400,700,900,100italic,300italic,400italic,700italic,900italic' rel='stylesheet' type='text/css'>
	<link href='http://fonts.googleapis.com/css?family=Arvo:400,700' rel='stylesheet' type='text/css'>
	
    <!-- Custom CSS-->
    <link href="css/general.css" rel="stylesheet">
	
	 <!-- Owl-Carousel -->
    <link href="css/custom.css" rel="stylesheet">
	<link href="css/owl.carousel.css" rel="stylesheet">
    <link href="css/owl.theme.css" rel="stylesheet">
	<link href="css/style.css" rel="stylesheet">
	<link href="css/animate.css" rel="stylesheet">
	
	<!-- Magnific Popup core CSS file -->
	<link rel="stylesheet" href="css/magnific-popup.css"> 
	
	<script src="js/modernizr-2.8.3.min.js"></script>  <!-- Modernizr /-->
	<!--[if IE 9]>
		<script src="js/PIE_IE9.js"></script>
	<![endif]-->
	<!--[if lt IE 9]>
		<script src="js/PIE_IE678.js"></script>
	<![endif]-->

	<!--[if lt IE 9]>
		<script src="js/html5shiv.js"></script>
	<![endif]-->
	
	
	

</head>

<body id="home">

	<!-- Preloader -->
	<div id="preloader">
		<div id="status"></div>
	</div>
	
	<!-- FullScreen -->
    <!--<div class="intro-header">
		<div class="col-xs-12 text-center abcen1">
			<h1 class="h1_home wow fadeIn" data-wow-delay="0.4s">Flatfy</h1>
			<h3 class="h3_home wow fadeIn" data-wow-delay="0.6s">Clean & minimal Theme</h3>
			<ul class="list-inline intro-social-buttons">
				<li><a href="https://twitter.com/galantiandrea" class="btn  btn-lg mybutton_cyano wow fadeIn" data-wow-delay="0.8s"><span class="network-name">Twitter</span></a>
				</li>
				<li id="download" ><a href="#downloadlink" class="btn  btn-lg mybutton_standard wow swing wow fadeIn" data-wow-delay="1.2s"><span class="network-name">Free Download</span></a>
				</li>
			</ul>
		</div>    
        <!-- /.container -->
		<div class="col-xs-12 text-center abcen wow fadeIn">
			<div class="button_down "> 
				<a class="imgcircle wow bounceInUp" data-wow-duration="1.5s"  href="#whatis"> <img class="img_scroll" src="img/icon/circle.png" alt=""> </a>
			</div>
		</div>
    </div>
	
	<!-- NavBar-->
	<nav class="navbar-default" role="navigation">
		<div class="container">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
					<span class="sr-only">Toggle navigation</span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="#home">REA-AED</a>
			</div>

			<div class="collapse navbar-collapse navbar-right navbar-ex1-collapse">
				<ul class="nav navbar-nav">
					
					<li class="menuItem"><a href="index.html">Home</a></li>
					<ul class="nav navbar-nav navbar-right">
						<li class="dropdown">
						  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Aulas<span class="caret"></span></a>
						  <ul class="dropdown-menu">
							<li><a href="aula_cb.html">Conceitos Básicos</a></li>
							<li><a href="aula_seq.html">Estrutura Sequencial</a></li>
							<li><a href="aula_cond.html">Estrutura Condicional</a></li>
							<li><a href="aula_rep.html">Estrutura de Repetição</a></li>
							<li><a href="aula_vet.html">Vetores</a></li>
							<li><a href="aula_mat.html">Matrizes</a></li>
							<li><a href="aula_func.html">Procedimentos e Funções</a></li>
							<li><a href="aula_reg.html">Registros</a></li>
							<li><a href="aula_rec.html">Recursividade</a></li>
							<li><a href="aula_pon.html">Ponteiros</a></li>
							<li><a href="aula_aloc.html">Alocação Dinâmica</a></li>
							<li><a href="aula_arq.html">Arquivos</a></li>
							<li><a href="aula_list.html">Listas</a></li>
							<li><a href="aula_pilha_fila.html">Pilha e Fila</a></li>
							<li><a href="aula_arv.html" style= "color:#04B486">Árvore Binária</a></li>
							<li role="separator" class="divider"></li>
						  </ul>
						</li>
						<li class="menuItem"><a href="biblio.html">Bibliografia</a></li>
					</ul>
				</ul>
			</div>
		   
		</div>
	</nav> 
	
	<!-- What is -->
	<div id="whatis" class="content-section-a" style="border-top: 0">
		<div class="container">
			<div class="col-md-8 col-md-offset-2 text-center wrap_title">
				<h2>Árvore Binária</h2>
				<p class="lead" style="margin-top:0">O objetivo dessa unidade é apresentar o conteúdo relacionado à Árvore Binária. Será feita
				uma abordagem focando na linguagem C.</p>
			</div>
			<div class="col-md-10 col-md-offset-1  wrap_title">
				<div class="row">
					<h3>Estruturas de dados do tipo árvore</h3>
					<p align="justify">Diferentemente das estruturas de dados vistas nas últimas aulas (listas, pilhas e filas), as estruturas de dados do tipo árvore não apresentam uma forma linear, ou seja, os elementos não estão armazenados de maneira sequencial. .</p>
						<div class="row"><center><img class="img-responsive " src="img/arv/arvore.PNG" alt="" align="middle"><center></div>
				</div>
				<div class="row">
					<h3>Árvores binárias</h3>
						<p align="justify">Uma arvore binária é uma estrutura de dados com capacidade de armazenar finitos elementos e que pode ser representada como uma hierarquia onde cada elemento é chamado de nó. O nó inicial ou o primeiro elemento é chamado de raiz.</p>
						<p>Uma árvore pode estar vazia ou pode ser particionada em três subconjuntos:</p>
						<ul style="list-style-type:circle">
						<li>•	 Nó Raiz</li>
						<li>•	 Sub-árvore direita</li>
						<li>•	 Sub-árvore esquerda</li>
					</ul>
					<div class="row"><center><img class="img-responsive " src="img/arv/sub_conjuntos.PNG" alt="" align="middle"><center></div>
					<h4>Propriedades de uma árvore binária</h4>
					<p> <b>A) </b>  Os nós da sub-árvore esquerda são menores que os nós da sub-árvore direita e também menores que o nó raiz.</p>
					<p> <b>B) </b> Os nós da sub-árvore direita são maiores que os nós da sub-árvore esquerda e também maiores que o nó raiz.</p>
					<p> <b>C) </b>Nomenclatura dos nós:</p>
					<ul style="list-style-type:circle">
						<li>•	 <b>Nó Raiz:</b> é o nó do topo da árvore;</li>
						<li>•	 <b> Nó Pai:</b>  nó que está acima de um nó filho e diretamente ligado a ele;</li>
						<li>•	  <b>Nó Filho:</b> nó que está abaixo de um nó pai e diretamente ligado a ele;</li>
						<li>•	  <b>Folhas:</b>  são os nós que não têm filhos; são os últimos nós da árvore;</li>
					</ul>
					<div class="row"><center><img class="img-responsive " src="img/arv/filho_pai.PNG" alt="" align="middle"><center></div>
					<p> <b>D) </b>Nós ancestrais são os nós que estão acima de um nó e possuem ligação direta ou indireta;</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/ancestral.PNG" alt="" align="middle"><center></div>
					<p> <b>E) </b>Nós descendentes são os nós que estão abaixo de um nó e possuem ligação direta ou indireta;</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/descendente.PNG" alt="" align="middle"><center></div>
					
					<p> <b>F) </b>Em uma árvore binária um nó pai pode ter no máximo dois nós filhos</p>	
					<p> <b>G) </b>O grau de um nó representa seu número de sub-árvores (nós filhos). Em uma árvore binária, o grau máximo de um nó é 2 e o menor 0.</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/grau.PNG" alt="" align="middle"><center></div>
					<p> <b>H) </b>O nível de um nó representa a sua distância do nó raiz, logo o nível do nó raiz é 0;</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/nivel.PNG" alt="" align="middle"><center></div>
					<p> <b>I) </b>O número máximo de nós em um nível é dado pela expressão 2^n, sendo n o nível da árvore;</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/max_nos.PNG" alt="" align="middle"><center></div>
					<p> <b>J) </b>Árvore estritamente binária: todos os nós da árvore tem 0 ou 2 filhos</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/estritamente_binaria.PNG" alt="" align="middle"><center></div>
					<p> <b>K) </b>Árvore completa: todos os nós com menos de dois filhos ficam no último e penúltimo nível da árvore</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/completa.PNG" alt="" align="middle"><center></div>
					<p> <b>L) </b>Árvore cheia: árvore estritamente binária e completa.</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/cheia.PNG" alt="" align="middle"><center></div>
					<p> <b>M) </b>Em consultas em árvores binárias todos os nós da ávore são listados, mudando-se apenas a ordem da listagem de acordo com o tipo de consulta realizada.</p>
					<p>Temos três tipo de consultas:</p>
					<ul style="list-style-type:circle">
					<li><b>Em ordem:</b> neste tipo de consulta cada árvore é mostrada primeiramente com o ramo da esquerda, depois a raiz e por fim o ramo da direita.</li>
					<li><b>Pré-ordem:</b> neste tipo de consulta cada árvore é mostrada primeiramente com a raiz, depois o ramo da esquerda e por fim o ramo da direita.</li>
					<li><b>Pós-ordem:</b> neste tipo de consulta cada árvore é mostrada primeiramente com o ramo da esquerda, depois o ramo da direita e por fim a raiz.</li>
					<div class="row"><center><img class="img-responsive " src="img/arv/consultas.PNG" alt="" align="middle"><center></div>
					</ul>
				</div>
				<center>
					<h3>Video Explicativo - Árvore Binária Parte 1</h3>
							<p>                                      </p>
							<video width=80% height="315" class="img-responsive" controls>
							  <source src="video/arvb_pt1.mp4" type="video/mp4">
							  <source src="movie.ogg" type="video/ogg">
							  Your browser does not support the video tag.
							</video>
				</center>
				<div class="row">
					<h3>Implementação</h3>
					<h4>Primeiros passos para a construção de uma árvore binária</h4>
					<p>Para representarmos um elemento da árvore (um nó), será definido um registro da seguinte maneira: </p>
					<pre>
<span class="com">/*definição da estrutura que representará cada elemento da árvore binária*/</span>
<span class="blue">struct</span> No{
    <span class="blue">int</span> num;  /*será uma árvore que armazenará inteiros*/
    <span class="blue">struct</span> No *esq, *dir; /*ponteiros para fazer a ligação entre nós a esquerda e a direita*/
};
<span class="green">typedef</span> <span class="blue">struct</span> No No;</pre>
					<p>Para melhor controlar a árvore utilizamos uma estrutura do tipo Árvore. Ela contém um ponteiro do tipo No, o ponteiro raiz, que irá armazenar o endereço de memória do nó que for a raiz da árvore.</p>
					<pre>
<span class="blue">struct</span> Arvore{
    <span class="blue">struct</span> No *raiz; <span class="com">/*ponteiro que irá apontar para a raiz da árvore*/</span>
};
<span class="green">typedef</span> <span class="blue">struct</span> Arvore Arvore;
					</pre>
					<p>Para o auxílio em algumas operações, vamos utilizar também uma estrutura do tipo pilha. Assim conforme a aula sobre pilha definimos:</p>
					<pre>
<span class="com">/*definição do estrutura que irá representar cada elemento da árvore em um pilha*/</span>
<span class="blue">struct</span> Elemento{
	<span class="blue">struct</span> No *num;
	<span class="blue">struct</span> Elemento *prox;
};
<span class="green">typedef</span> <span class="blue">struct</span> Elemento Elemento;

<span class="com">/*registro do tipo Pilha contento um ponteiro "topo" do tipo Elemento para controlar a pilha*/</span>
<span class="blue">struct</span> Pilha{
    <span class="blue">struct</span> Elemento *topo; <span class="com">/*aponta para o elemento qu esta no topo da pilha*/</span>
};
<span class="green">typedef <span class="blue">struct</span> Pilha Pilha;</pre>
					<p>Vamos utilizar alguns ponteiros auxiliares durante as operações. Serão estes</p>
					<pre>
<span class="com">/*ponteiros auxiliares*/</span>
No *aux;
No *aux1;
No *novo;
No *anterior;

Elemento *aux2;</pre>
					<p>Nesse ponto definiremos também uma função cria_arvore( ). Ela será utilizada para alocar dinamicamente o espaço necessário para armazenar seu ponteiro "topo" e irá inicializá-lo com NULL, indicando que inicialmente a árvore está vazia. Não podemos nos esquecer também da função cria_pilha().</p>
					<pre>
Arvore* cria_arvore(){
    <span class="com">/*alocação do ponteiro arv para controlar a árvore*/</span>
    Arvore* arv = (Arvore*) malloc(<span class="green">sizeof</span>(Arvore));
    <span class="green">if</span>(arv != <span class="green">NULL</span>){
        arv->raiz= <span class="green">NULL</span>;  <span class="com">/*a pilha inicia-se vazia, portanto seu topo é igual a NULL*/</span>
    }
    <span class="green">return</span> arv;
}

Pilha* cria_pilha(){
    <span class="com">/*alocação do ponteiro pi para controlar a pilha*/</span>
    Pilha* pi = (Pilha*) malloc(<span class="green">sizeof</span>(Pilha));
    if(pi != <span class="green">NULL</span>){
        pi->topo= <span class="green">NULL</span>;  <span class="com">/*a pilha inicia-se vazia, portanto seu topo é igual a NULL*/</span>
    }
    <span class="green">return</span> pi;
}</pre>
					<p>Na função main, devemos definir um ponteiro do tipo Arvore e outro do tipo Pilha. Eles receberão os endereços do espaço alocado pelas funções cria_arvore( ) e cria_pilha( ) respectivamente. Além disso servirão de parâmetro para as demais funções seguintes.</p>
					<pre>
<span class="blue">int</span> main(){
    Arvore *arv = cria_arvore();
    Pilha *pi = cria_pilha();
	<span class="com">...blocos de chamada de função...</span>
    <span class="green">return</span> <span class="number">0</span>;
}	
					</pre>
					<h3>Operações com árvores binárias:</h3>
					<p>Serão realizadas as seguintes operações com árvores binárias:</p>
					<ul style="list-style-type:circle">
							<li>Inserção de um nó na árvore;</li>
							<li>Consultar um nó árvore;</li>
							<li>Consultar árvore em ordem;</li>
							<li>Consultar árvore em pré-ordem;</li>
							<li>Consultar árvore em pós-ordem;</li>
							<li>Remoção de um nó da árvore;</li>
							<li>Esvaziar árvore.</li>
					</ul>
					
					<h4>Inserção de um nó na árvore</h4>
					<p>Esta é a implementação da função que utilizaremos para inserir um elemento na árvore.</p>
					<pre>
<span class="blue">void</span> insere_elemento(Arvore *arv){
	<span class="com">/*a cada inserção alocamos dinamicamente um espaço para um novo elemento*/</span>
	No *novo =(No*) malloc(<span class="green">sizeof</span>(No));
	printf(<span class="text">"Digite o numero a ser inserido na arvore: "</span>);
	scanf(<span class="text">"%d"</span>,&novo->num);
	novo->esq = <span class="green">NULL</span>;
	novo->dir = <span class="green">NULL</span>;
	<span class="com">/*caso a árvore esteja vazia, o elemento inserido será a raiz */</span>
	<span class="green">if</span>(arv->raiz == <span class="green">NULL</span>){
		arv->raiz = novo;
	<span class="com">/*caso a árvore  já contenha algum elemento*/</span>
	}<span class="green">else</span>{
		<span class="com">/*variável para verificação*/</span>
		<span class="blue">int</span> achou;
		<span class="com">/*aux aponta para o mesmo endereço de raiz*/</span>
		aux = arv->raiz;
		achou = <span class="number">0</span>;
		<span class="com">/*é feita uma busca em toda árvore para saber onde novo deve ser enserido*/</span>
		<span class="green">while</span>(achou == <span class="number">0</span>){
			<span class="com">/*caso o novo numero a ser inserido seja menor que aux-> num*/</span>
			<span class="green">if</span>(novo->num < aux->num){
				<span class="com">/*caso não aja nenhum elemento a esquerda de aux, novo será inserido a esquerda dele*/</span>
				<span class="green">if</span>(aux->esq == <span class="green">NULL</span>){
					aux->esq = novo;
					achou = <span class="number">1</span>;
				<span class="com">/*caso já exista um elemento a esquerda de aux, aux  aponta para este elemento  e uma nova iteração será realizada*/</span>
				}<span class="green">else</span>{
					aux = aux->esq;
				}
			<span class="com">/*caso o novo numero a ser inserido seja maior ou igual a aux-> num*/</span>
			}<span class="green">else if</span>(novo->num >= aux->num){
				<span class="com">/*caso não aja nenhum elemento a direita de aux, novo será inserido a direita dele*/</span>
				<span class="green">if</span>(aux->dir == <span class="green">NULL</span>){
					aux->dir = novo;
					achou = <span class="number">1</span>;
				}<span class="green">else</span>{
					<span class="com">/*caso já exista um elemento a direita de aux, aux  aponta para este elemento  e uma nova iteração será realizada*/</span>
					aux = aux->dir;
				}
			}
		}
	}
	printf(<span class="text">"\nNumero inserido na arvore!"</span>);
	getch();
}	</pre>
					<p>Na prática isso aconteceria da seguinte maneira:</p>
					<p>Inicialmente temos o ponteiro raiz apontado para null:</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/inicio_arvore.PNG" alt="" align="middle"><center></div>
					<p>Agora vamos as inserções:</p>
					<p>Inserção do número 37 na árvore:</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/insere1.PNG" alt="" align="middle"><center></div>
					<p>Inserção do número 20 na árvore:</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/insere2.PNG" alt="" align="middle"><center></div>
					<p>Inserção do número 10 na árvore:</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/insere3.PNG" alt="" align="middle"><center></div>
					<p>Inserção do número 30 na árvore:</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/insere4.PNG" alt="" align="middle"><center></div>
					<p>Inserção do número 80 na árvore:</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/insere5.PNG" alt="" align="middle"><center></div>
					<p>Inserção do número 100 na árvore:</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/insere6.PNG" alt="" align="middle"><center></div>
					<p>Inserção do número 180 na árvore:</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/insere7.PNG" alt="" align="middle"><center></div>
					<p>Inserção do número 90 na árvore:</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/insere8.PNG" alt="" align="middle"><center></div>
					<p>Inserção do número 5 na árvore:</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/insere9.PNG" alt="" align="middle"><center></div>
					<h4>Consultar um nó na árvore</h4>
					<p>Será feita uma busca pela árvore com o objetivo de encontrar determinado dado armazenado. A cada nó visitado verifica-se primeiramente se este contém o dado procurado. Caso não contenha, é verificado se o dado procurado é maior ou menor que o dado do nó em questão. Se for maior, a busca irá para a sub-árvore direita deste nó e , se for menor, para a sub-árvore esquerda. </p>
					<pre>
<span class="blue">void</span> consulta_no(Arvore *arv){
	<span class="com">/*caso a árvore esteja vazia*/</span>
	<span class="green">if</span>(arv->raiz == <span class="green">NULL</span>){
		printf(<span class="text">"\nArvore Vazia!!"</span>);
	}<span class="green">else</span>{
	    <span class="blue">int</span> numero, achou;
		printf(<span class="text">"Digite o numero a ser consultado: "</span>);
		scanf(<span class="text">"%d"</span>, &numero);
		achou = <span class="number">0</span>;
		<span class="com">/*aux aponta para o mesmo endereço de raiz*/</span>
		aux = arv->raiz;
		<span class="com">/*enquanto aux não apontar para NULL e achou for igual a 0 será feita uma busca na árvore*/</span>
		<span class="green">while</span>(aux != NULL && achou == <span class="number">0</span>){
			<span class="com">/*caso aux-> seja igual o número buscado*/</span>
			<span class="green">if</span>(aux->num == numero){
				printf(<span class="text">"Numero %d encontrado!"</span>, numero);
				achou = <span class="number">1</span>;
			<span class="com">/*do contrário verificamos se o número está a direita ou a esquerda de aux->num e atualizamos aux*/</span>
			}<span class="green">else if</span>(numero < aux->num){
				aux = aux->esq;
				}<span class="green">else</span>{
					aux = aux->dir;
				}
        }
        <span class="green">if</span>(achou == <span class="number">0</span>) printf(<span class="text">"Número não encontrado!"</span>);
    }

	getch();
}	</pre>
					<h4>Consultar árvore em ordem</h4>
					<p>Para realizarmos a consulta em ordem na árvore utilizaremos a seguinte implementação:</p>
					<pre>
<span class="com">/*consulta em ordem mostra os nós na seguinte ordem
	1° ramo da esquerda
	2° raiz
	3° ramo da direita	*/</span>
<span class="blue">void</span> consulta_arvore_ordem(Arvore *arv, Pilha *pi){
	<span class="com">/*caso a árvore esteja vazia*/</span>
	<span class="green">if</span>(arv->raiz == <span class="green">NULL</span>){
		printf(<span class="text">"\nArvore Vazia!!"</span>);
	<span class="com">/*caso a árvore contenha elementos*/</span>
	}<span class="green">else</span>{
		<span class="com">/*aux aponta para o endereço de raiz*/</span>
		aux = arv->raiz;
		<span class="com">/*como aqui utilizaremos uma pilha, incializamos seu topo com null*/</span>
		pi->topo = <span class="green">NULL</span>;
		<span class="green">do</span>{
			<span class="com">/*caminha pela árvore pelo ramo da esquerda até NULL, colocando cada elemento visitado na pilha */</span>
			<span class="green">while</span>(aux != <span class="green">NULL</span>){
				<span class="com">/*alocamos um espaço para inserir o elemento a ser mostrado na pilha*/</span>
				Elemento *aux_pilha =(Elemento*) malloc(<span class="green">sizeof</span>(Elemento));
				<span class="com">/*a pilha recebe o elemento apontado por auix*/</span>
				aux_pilha->num = aux;
				<span class="com">/*para encadear os elementos da pilha, aux_pilha->prox aponta para o topo da pilha*/</span>
				aux_pilha->prox = pi->topo;
				<span class="com">/*o topo da pilha apontará para o elemento que está sendo inserido na pilha*/</span>
				pi->topo = aux_pilha;
				<span class="com">/*aux aponta para o elemento a esquerda do aux atual*/</span>
				aux = aux->esq;
			}
			<span class="com">/*imprimiremos aos elementos empilhados no momento a partir do topo */</span>
			<span class="green">if</span>(pi->topo != <span class="green">NULL</span>){
				aux2 = pi->topo;
				printf(<span class="text">"%d "</span>, aux2->num->num);
				<span class="com">/*caso aja um elemento a direita do elemento apontado por topo na árvore, seu prox será NULL, portanto ao encontrar
				um elemento a direita do elemento impresso retornaremos ao while anterior antes de imprimir o restante da pilha*/</span>
				aux = pi->topo->num->dir;
				pi->topo = pi->topo->prox;
			}
		}<span class="green">while</span>(pi->topo != <span class="green">NULL</span> || aux != <span class="green">NULL</span>);
	}
	getch();
}</pre>
					<p>Com base na árvore final apresentada nos processos de inserção teremos o seguinte resultado da consulta:</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/em_ordem.PNG" alt="" align="middle"><center></div>
					<div class="row"><center><img class="img-responsive " src="img/arv/consulta_ordem.PNG" alt="" align="middle"><center></div>
					<h4>Consultar árvore em pré-ordem</h4>
					<p>Para realizarmos a consulta em pré-ordem na árvore utilizaremos a seguinte implementação:</p>
					<pre>
<span class="com">/*consulta em pré-ordem mostra os nós na seguinte ordem
	1° raiz
	2° ramo da esquerda
	3° ramo da direita	*/</span>
<span class="blue">void </span>consulta_arvore_pre_ordem(Arvore *arv, Pilha *pi){
	<span class="com">/*caso a árvore esteja vazia*/</span>
	<span class="green">if</span>(arv->raiz == <span class="green">NULL</span>){
		printf(<span class="text">"\nArvore Vazia!!"</span>);
	<span class="com">/*caso a árvore contenha elementos*/</span>
	}<span class="green">else</span>{
		<span class="com">/*aux aponta para o endereço de raiz*/</span>
		aux = arv->raiz;
		<span class="com">/*como aqui utilizaremos uma pilha, incializamos seu topo com null*/</span>
		pi->topo = <span class="green">NULL</span>;
		<span class="green">do</span>{
			<span class="com">/*caminha pela árvore mostrando cada elemento visitado, e também coloca cada elemento visitado na pilha */</span>
			<span class="green">while</span>(aux != <span class="green">NULL</span>){
				<span class="com">/*alocamos um espaço para inserir um elemento na pilha*/</span>
				Elemento *aux_pilha =(Elemento*) malloc(<span class="green">sizeof</span>(Elemento));
				<span class="com">/*impressão do elemento apontado por aux*/</span>
				printf(<span class="text">"%d "</span>, aux->num);
				<span class="com">/*colocamos na pilha o elemento impresso*/</span>
				aux_pilha->num = aux;
				aux_pilha->prox = pi->topo;
				pi->topo = aux_pilha;
				<span class="com">/*fazemos com que aux aponte para o elemento a sua esquerda*/</span>
				aux = aux->esq;
			}
			<span class="green">if</span>(pi->topo != <span class="green">NULL</span>){
				aux_pilha = pi->topo;
				pi->topo = pi->topo->prox;
				<span class="com">/*aux aponta para o elemento a direita de topo na árvore*/</span>
				aux = aux_pilha->num->dir;
			}
		}<span class="green">while</span>(pi->topo != <span class="green">NULL</span> || aux != <span class="green">NULL</span>);
	}
	getch();
}		</pre>
					<p>Com base na árvore final apresentada nos processos de inserção teremos o seguinte resultado da consulta:</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/pre_ordem.PNG" alt="" align="middle"><center></div>
					<div class="row"><center><img class="img-responsive " src="img/arv/consulta_preordem.PNG" alt="" align="middle"><center></div>
					<center>
					<h3>Video Explicativo - Árvore Binária Parte 2</h3>
							<p>                                      </p>
							<video width=80% height="315" class="img-responsive" controls>
							  <source src="video/arvb_pt2.mp4" type="video/mp4">
							  <source src="movie.ogg" type="video/ogg">
							  Your browser does not support the video tag.
							</video>
				</center>
					<h4>Consultar árvore em pós-ordem</h4>
					<p>Para realizarmos a consulta em pós-ordem na árvore utilizaremos a seguinte implementação:</p>
					<pre>
<span class="com">/*consulta em pós-ordem mostra os nós na seguinte ordem
	1° ramo da esquerda
	2° ramo da dreita
	3° raiz */</span>
<span class="blue">void</span> consulta_arvore_pos_ordem(Arvore *arv, Pilha *pi){
	<span class="com">/*caso a árvore esteja vazia*/</span>
	<span class="green">if</span>(arv->raiz == <span class="green">NULL</span>){
		printf(<span class="text">"\nArvore Vazia!!"</span>);
	<span class="com">/*caso a árvore contenha elementos*/</span>
	}<span class="green">else</span>{
		<span class="com">/*aux aponta para o endereço de raiz*/</span>
		aux = arv->raiz;
		<span class="com">/*como aqui utilizaremos uma pilha, incializamos seu topo com null*/</span>
		pi->topo = <span class="green">NULL</span>;
		<span class="green">do</span>{
			<span class="green">do</span>{
				<span class="com">/*caminha pela árvore pelo ramo da esquerda até NULL, colocando cada elemento visitado na pilha, além disso
				   antes de colocar a raiz de cada sub-árvore na pilha também caminha no ramo da direita*/</span>
				<span class="green">while</span>(aux != <span class="green">NULL</span>){
					<span class="com">/*alocamos um espaço para inserir um elemento na pilha*/</span>
					Elemento *aux_pilha = (Elemento*) malloc(<span class="green">sizeof</span>(Elemento));
					<span class="com">/*a pilha recebe o elemento apontado por auix*/</span>
					aux_pilha->num = aux;
					<span class="com">/*para encadear os elementos da pilha, aux_pilha->prox aponta para o topo da pilha*/</span>
					aux_pilha->prox =pi-> topo;
					<span class="com">/*o topo da pilha apontará para o elemento que está sendo inserido na pilha*/</span>
					pi->topo = aux_pilha;
					<span class="com">/*aux aponta para o elemento a esquerda do aux atual*/</span>
					aux = aux->esq;
				}
				<span class="com">/*caso o exista um elemento a direita do endereço apontado por topo na árvore, aux aponta para esse elemento*/</span>
				<span class="green">if</span>(pi->topo->num->dir != <span class="green">NULL</span>){
					aux = pi->topo->num->dir;
				}
			}<span class="green">while</span>(aux != <span class="green">NULL</span>);
			<span class="green">if</span>(pi->topo!= <span class="green">NULL</span>){
				<span class="com">/*imprime o elemento apontado por topo*/</span>
				printf(<span class="text">"%d "</span>, pi->topo->num->num);
				<span class="com">/*se ainda existirem elementos na pilha além de topo*/</span>
				<span class="green">if</span>(pi->topo->prox != <span class="green">NULL</span>){
					<span class="com">/*caso o exista um elemento a direita do endereço apontado por topo na árvore e esse elemento seja diferente de topo,
					aux apontara para esse elementoe topo apontará para o próximo elemento da pilha*/</span>
					<span class="green">if</span>(pi->topo->prox->num->dir != <span class="green">NULL</span> && pi->topo->prox->num->dir != pi->topo->num){
						aux = pi->topo->prox->num->dir;
						pi->topo = pi->topo->prox;
					<span class="com">/*caso o exista um elemento a direita do endereço apontado por topo na árvore e esse elemento seja igual a topo,
						topo apontará para o próximo elemento da pilha e este será  impresso*/</span>
					}<span class="green">else</span>{
						<span class="com">/*caso o exista um elemento a direita do endereço apontado por topo na árvore e esse elemento seja igual a topo,
						topo apontará para o próximo elemento da pilha e este será  impresso*/</span>
						<span class="green">while</span>(pi->topo->prox != <span class="green">NULL</span> && pi->topo->prox->num->dir == pi->topo->num){
							pi->topo = pi->topo->prox;
							printf(<span class="text">"%d "</span>, pi->topo->num->num);
						}
						<span class="com">/*topo apontará para o próximo elemento da pilha*/</span>
						pi->topo = pi->topo->prox;
						<span class="com">/*se topo não for null aux aponta para o elemento a direita do endereço apontado por topo na árvoree*/</span>
						<span class="green">if</span>(pi->topo != <span class="green">NULL</span>){
							aux  = pi->topo->num->dir;
						<span class="com">/*caso contrário aux recebe NULL*/</span>
						}<span class="green">else</span>{
							aux = <span class="green">NULL</span>;
						}
					}
				<span class="com">/*se topo igual a NULL*/</span>
				}<span class="green">else</span>{
					pi->topo = pi->topo->prox;
					aux = <span class="green">NULL</span>;
				}
			}
		}<span class="green">while</span>(pi->topo != <span class="green">NULL</span> || aux != <span class="green">NULL</span>);

	}
	getch();
}</pre>
					<p>Com base na árvore final apresentada nos processos de inserção teremos o seguinte resultado da consulta:</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/pos_ordem.PNG" alt="" align="middle"><center></div>
					<div class="row"><center><img class="img-responsive " src="img/arv/consulta_posordem.PNG" alt="" align="middle"><center></div>
					<h4>Remover um nó da árvore</h4>
					<p>Para removermos um elemento da árvore, utilizaremos a seguinte função:</p>
					<pre>
<span class="blue">void</span> remove_elemento(Arvore *arv){
	<span class="com">/*caso a árvore esteja vazia*/</span>
	<span class="green">if</span>(arv->raiz == <span class="green">NULL</span>){
		printf(<span class="text">"\nArvore Vazia!!"</span>);
	<span class="com">/*caso a árvore contenha elementos*/</span>
	}<span class="green">else</span>{
	    <span class="blue">int</span> numero, achou;
		printf(<span class="text">"Digite o numero a ser removido da arvore: "</span>);
		scanf(<span class="text">"%d"</span>, &numero);
		<span class="com">/*aux aponta para o endereço de raiz*/</span>
		aux = arv->raiz;
		achou = <span class="number">0</span>;
		<span class="com">/*varre toda a árvore a procura do número a ser removido*/</span>
		<span class="green">while</span>(aux != <span class="green">NULL</span> && achou == <span class="number">0</span>){
			<span class="green">if</span>(aux->num == numero){
				achou = <span class="number">1</span>;
			}<span class="green">else if</span>(aux->num > numero){
				aux = aux->esq;
				}<span class="green">else</span>{
					aux = aux->dir;
				}
        }
        <span class="com">/*caso o número não seja encontrado*/</span>
        <span class="green">if</span>(achou == <span class="number">0</span>){
            printf(<span class="text">"Numero nao encontrado!"</span>);
        <span class="com">/*caso o número seja encontrado*/</span>
        }<span class="green">else</span>{
            <span class="com">/*caso o número a ser removido não seja a raiz*/</span>
            <span class="green">if</span>(aux != arv->raiz){
                anterior = arv->raiz;
                <span class="com">/*aqui procura-se o número anterior ao número a ser removido, o endereço deste será armazenado em anteirior*/</span>
                <span class="green">while</span>(anterior->dir != aux && anterior->esq != aux){
                    <span class="green">if</span>(anterior->num > numero){
                       <span class="com">/*o número esta a esqueda da árvore*/</span>
                        anterior = anterior->esq;
                    }<span class="green">else</span>{
                        <span class="com">/*o número esta a direita da árvore*/</span>
                        anterior = anterior->dir;
                    }
                }
                <span class="com">/*se o nó a ser removido for um nó folha*/</span>
                <span class="green">if</span>(aux->dir == <span class="green">NULL</span> && aux->esq == <span class="green">NULL</span>){
                        <span class="com">/*se o nó a ser removido esta a direita de aux*/</span>
                        <span class="green">if</span>(anterior->dir == aux){
                            anterior->dir = <span class="green">NULL</span>;
                        <span class="com">/*se o nó a ser removido esta a esquerda de aux*/</span>
                        }<span class="green">else</span>{
                            anterior->esq = <span class="green">NULL</span>;
                        }
                    free(aux);
                <span class="com">/*se o nó a ser removido for um nó não folha*/</span>
                }<span class="green">else</span>{
                    <span class="com">/*se o nó a ser removido tiver apenas filho a direita*/</span>
                    <span class="green">if</span>(aux->dir != <span class="green">NULL</span>  && aux->esq == <span class="green">NULL</span>){
                        <span class="com">/*se o nó a ser removido estiver a esquerda de anterior*/</span>
                        <span class="green">if</span>(anterior->esq == aux){
                            anterior->esq = aux->dir;
                        <span class="com">/*se o nó a ser removido estiver a direita de anterior*/</span>
                        }<span class="green">else</span>{
                            anterior->dir = aux->dir;
                        }
                        free(aux);
                    <span class="com">/*se o nó a ser removido tiver apenas filho a esquerda*/</span>
                    }<span class="green">else if</span>(aux->esq != <span class="green">NULL</span> && aux->dir == <span class="green">NULL</span>){
                       <span class="com">/*se o nó a ser removido estiver a esquerda de anterior*/</span>
                        <span class="green">if</span>(anterior->esq == aux){
                            anterior->esq = aux->esq;
                        <span class="com">/*se o nó a ser removido estiver a direita de anterior*/</span>
                        }<span class="green">else</span>{
                            anterior->dir = aux->esq;
                        }
                        free(aux);
                    <span class="com">/*se o nó a ser removido tiver filho a direita e a esquerda*/</span>
                    }<span class="green">else if</span>(aux->esq != <span class="green">NULL</span> && aux->dir != <span class="green">NULL</span>){
                       <span class="com">/*se o nó a ser removido estiver a direita de anterior*/</span>
                        <span class="green">if</span>(anterior->dir == aux){
                            anterior->dir = aux->dir;
                            <span class="com">/*o nó a esquerda do nó a ser removido fica apontado por aux1*/</span>
                            aux1 = aux->esq;
                        <span class="com">/*se o nó a ser removido estiver a esquerda de anterior*/</span>
                        }<span class="green">else</span>{
                            anterior->esq = aux->dir;
                           <span class="com">/*o nó a direita do nó a ser removido fica apontado por aux1*/</span>
                            aux1 = aux->esq;
                        }
                        free(aux);
                        <span class="com">/*aux aponta para anteirior*/</span>
                        aux = anterior;
                        <span class="com">/*realocando o pedaço da árvore*/</span>
                        <span class="green">while</span>(aux != <span class="green">NULL</span>){
                            <span class="com">/*caso aux seja menor, que aux1*/</span>
                            <span class="green">if(</span>aux->num < aux1->num){
                                <span class="com">/*caso aux não tenha filho a direita*/</span>
                                <span class="green">if</span>(aux->dir == <span class="green">NULL</span>){
                                    aux->dir = aux1;
                                    aux = <span class="green">NULL</span>;
                                <span class="com">/*caso aux tenha filho a direita*/</span>
                                }<span class="green">else</span>{
                                    aux = aux->dir;
                                }
                            <span class="com">/*caso aux seja maior, que aux1*/</span>
                            }<span class="green">else if</span>(aux->num > aux1->num){
                               <span class="com">/*caso aux não tenha filho a esquerda*/</span>
                                <span class="green">if</span>(aux->esq == <span class="green">NULL</span>){
                                    aux->esq = aux1;
                                    aux = <span class="green">NULL</span>;
                                <span class="com">/*caso aux tenha filho a esquerda*/</span>
                                }<span class="green">else</span>{
                                    aux = aux->esq;
                                }
                            }
                        }
                    }
                }
            <span class="com">/*caso o número a ser removido não seja a raiz*/</span>
            }<span class="green">else</span>{
                <span class="com">/*se o nó a ser removido for raiz e folha*/</span>
                <span class="green">if</span>(aux->dir == <span class="green">NULL</span> && aux->esq == <span class="green">NULL</span>){
                    free(aux);
                    arv->raiz = <span class="green">NULL</span>;
                }<span class="green">else</span>{
                    <span class="com">/*se o nó a ser removido tiver apenas filho a direita*/</span>
                    <span class="green">if</span>(aux->dir != <span class="green">NULL</span> && aux->esq == <span class="green">NULL</span>){
                        arv->raiz = aux->dir;
                        free(aux);
                    <span class="com">/*se o nó a ser removido tiver apenas filho a esquerda*/</span>
                    }<span class="green">else if</span>(aux->esq != <span class="green">NULL</span> && aux->dir == <span class="green">NULL</span>){
                        arv->raiz = arv->raiz->esq;
                        free(aux);
                    <span class="com">/*se o nó a ser removido tiver filho a direita e a esquerda*/</span>
                    }<span class="green">else if</span>(aux->dir != <span class="green">NULL</span> && aux->esq != <span class="green">NULL</span>){
                        arv->raiz = aux->dir;
                        aux1 = aux->esq;
                        free(aux);
                        aux = arv->raiz;
                        <span class="com">/*realocando o pedaço da árvore*/</span>
                        <span class="green">while</span>(aux != <span class="green">NULL</span>){
                           <span class="com">/*caso aux seja menor, que aux1*/</span>
                            <span class="green">if</span>(aux->num < aux1->num){
                                <span class="com">/*caso aux não tenha filho a direita*/</span>
                                <span class="green">if</span>(aux->dir == <span class="green">NULL</span>){
                                    aux->dir = aux1;
                                    aux = <span class="green">NULL</span>;
                                <span class="com">/*caso aux tenha filho a direita*/</span>
                                }<span class="green">else</span>{
                                    aux = aux->dir;
                                }
                            <span class="com">/*caso aux seja maior, que aux1*/</span>
                            }<span class="green">else if</span>(aux->num > aux1->num){
                                <span class="com">/*caso aux não tenha filhos a esquerda*/</span>
                                <span class="green">if</span>(aux->esq == <span class="green">NULL</span>){
                                    aux->esq = aux1;
                                    aux = <span class="green">NULL</span>;
                                <span class="com">/*caso aux tenha filhos a esquerda*/</span>
                                }<span class="green">else</span>{
                                    aux = aux->esq;
                                }
                            }
                        }
                    }
                }
            }
            printf(<span class="text">"Numero excluido da Arvore!"</span>);
        }
	}
	getch();
}</pre>
					<p>Agora vamos às remoções:</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/insere9.PNG" alt="" align="middle"><center></div>
					<p>Remoção do número 180 da árvore:</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/remove1.PNG" alt="" align="middle"><center></div>
					<p>Remoção do número 80 da árvore:</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/remove2.PNG" alt="" align="middle"><center></div>
					<p>Remoção do número 10 da árvore:</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/remove3.PNG" alt="" align="middle"><center></div>
					<p>Remoção do número 20 da árvore:</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/remove4.PNG" alt="" align="middle"><center></div>
					<p>Remoção do número 37 da árvore:</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/remove5.PNG" alt="" align="middle"><center></div>
					
					<h4>Esvaziar árvore</h4>
					<p>Nesta última operação esvaziaremos a nossa árvore, ou seja, removeremos todos os seus elementos restantes. Esta é a implementação utilizada:</p>
					
					<pre>
void esvaziar_arvore(Arvore *arv, Pilha *pi){
	<span class="com">/*caso a árvore esteja vazia*/</span>
	<span class="green">if</span>(arv->raiz == <span class="green">NULL</span>){
		printf(<span class="text">"\nArvore Vazia!!"</span>);
	<span class="com">/*caso a árvore contenha elementos*/</span>
	}<span class="green">else</span>{
        <span class="com">/*aux aponta para o endereço de raiz*/</span>
	    aux = arv->raiz;
        <span class="com">/*como aqui utilizaremos uma pilha, incializamos seu topo com null*/</span>
	    pi->topo = <span class="green">NULL</span>;
	    <span class="green">do</span>{
	        <span class="green">whil</span>e(aux != <span class="green">NULL</span>){
                Elemento *aux_pilha =(Elemento*) malloc(<span class="green">sizeof</span>(Elemento));
                <span class="com">/*impressão do elemento apontado por aux*/</span>
                printf(<span class="text">"%d </span>", aux->num);
                <span class="com">/*colocamos na pilha o elemento impresso*/</span>
                aux_pilha->num = aux;
                aux_pilha->prox = pi->topo;
                pi->topo = aux_pilha;
                <span class="com">/*fazemos com que aux aponte para o elemento a sua esquerda*/</span>
                aux = aux->esq;
	        }
	        <span class="green">if</span>(pi->topo != <span class="green">NULL</span>){
                aux2 = pi->topo;
                pi->topo = pi->topo->prox;
                <span class="com">/*aux aponta para o elemento a direita de topo na árvore*/</span>
                aux = aux2->num->dir;
	        }

	    }<span class="green">while</span>(pi->topo != <span class="green">NULL</span> || aux != <span class="green">NULL</span>);
	    aux2 = pi->topo;
        <span class="com">/*passagem por todos os elementos da pilha e removendo cada um deles*/</span>
	    <span class="green">while</span>(aux2 != <span class="green">NULL</span>){
            pi->topo = pi->topo->prox;
            free(pi->topo->num);
            free(aux2);
            aux2 = pi->topo;
	    }
	    arv->raiz = <span class="green">NULL</span>;
	    printf((<span class="text">"\nArvore esvaziada"</span>);

	}
	getch();
}</pre>
					<p>O resultado final após essa operação seria esse:</p>
					<div class="row"><center><img class="img-responsive " src="img/arv/inicio_arvore.PNG" alt="" align="middle"><center></div>
				</div>
				<center>
				<h3>Video Explicativo - Ávore Binária Parte 3</h3>
					<p>                                      </p>
					<video width=80% height="315" class="img-responsive" controls>
					  <source src="video/alocacao.mp4" type="video/mp4">
					  <source src="movie.ogg" type="video/ogg">
					  Your browser does not support the video tag.
					</video>
				</center>
				
				
			
			
					
			<!-- /.col-lg-4 -->
			
			</div>
				
		</div>
	</div>
	<div id="ex" class="content-section-b" style="border-top: 0">
		<div class="container">
			<div class="col-md-6 col-md-offset-3 text-center wrap_title">
				<h2>Exercícios</h2>
			</div>
			<center>
			<div class="row">
				<div class="col-sm-4 col-sm-offset-4 wow fadeInDown text-center">
					<a href="exercicios/lista15.docx">
					  <img class="rotate" src="img/icon/pdf.png" alt="Generic placeholder image">
					  <h3>Download</h3>
					  <center><p text-align: center>Dowload lista de exercícios para treinamento de Árvore Binária</p></center>
					</a>
				  <!-- <p><a class="btn btn-embossed btn-primary view" role="button">View Details</a></p> -->
				</div><!-- /.col-lg-4 -->
				
			</div><!-- /.row -->
		</div>
	</div>
	
	
	
	<footer>
      <div class="container">
        <div class="row">
          <div class="col-md-7">
             <h3 class="footer-title">REA-AED</h3>
            <p>Desenvolvido por Gabriel Bueno da Silva<br>
			<p>Contato: gabrielbuenodasilva@yahoo.com.br</p>
			
			<!-- LICENSE -->
			<p>Utilização do tema:</p>
			<a rel="cc:attributionURL" href="http://www.andreagalanti.it/flatfy"
		   property="dc:title">Flatfy Theme </a> by
		   <a rel="dc:creator" href="http://www.andreagalanti.it"
		   property="cc:attributionName">Andrea Galanti</a>
		   is licensed to the public under 
		   <BR>the <a rel="license"
		   href="http://creativecommons.org/licenses/by-nc/3.0/it/deed.it">Creative
		   Commons Attribution 3.0 License - NOT COMMERCIAL</a>.
		   
	   
          </div> <!-- /col-xs-7 -->

          <div class="col-md-5">
            <div class="footer-banner">
            </div>
          </div>
        </div>
      </div>
    </footer>

    <!-- JavaScript -->
    <script src="js/jquery-1.10.2.js"></script>
    <script src="js/bootstrap.js"></script>
	<script src="js/owl.carousel.js"></script>
	<script src="js/script.js"></script>
	<!-- StikyMenu -->
	<script src="js/stickUp.min.js"></script>
	<script type="text/javascript">
	  jQuery(function($) {
		$(document).ready( function() {
		  $('.navbar-default').stickUp();
		  
		});
	  });
	
	</script>
	<!-- Smoothscroll -->
	<script type="text/javascript" src="js/jquery.corner.js"></script> 
	<script src="js/wow.min.js"></script>
	<script>
	 new WOW().init();
	</script>
	<script src="js/classie.js"></script>
	<script src="js/uiMorphingButton_inflow.js"></script>
	<!-- Magnific Popup core JS file -->
	<script src="js/jquery.magnific-popup.js"></script> 
</body>

</html>
