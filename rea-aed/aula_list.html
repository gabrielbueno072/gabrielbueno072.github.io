 <!-- FlatFy Theme - Andrea Galanti /-->
<!doctype html>
<!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if IE 9]>    <html class="no-js ie9" lang="en"> <![endif]-->
<!--[if gt IE 9]><!--> <html> <!--<![endif]-->
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0">
    <meta name="description" content="Flatfy Free Flat and Responsive HTML5 Template ">
    <meta name="author" content="">

    <title>Aula - Listas</title>

    <!-- Bootstrap core CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
 
    <!-- Custom Google Web Font -->
    <link href="font-awesome/css/font-awesome.min.css" rel="stylesheet">
    <link href='http://fonts.googleapis.com/css?family=Lato:100,300,400,700,900,100italic,300italic,400italic,700italic,900italic' rel='stylesheet' type='text/css'>
	<link href='http://fonts.googleapis.com/css?family=Arvo:400,700' rel='stylesheet' type='text/css'>
	
    <!-- Custom CSS-->
    <link href="css/general.css" rel="stylesheet">
	
	 <!-- Owl-Carousel -->
    <link href="css/custom.css" rel="stylesheet">
	<link href="css/owl.carousel.css" rel="stylesheet">
    <link href="css/owl.theme.css" rel="stylesheet">
	<link href="css/style.css" rel="stylesheet">
	<link href="css/animate.css" rel="stylesheet">
	
	<!-- Magnific Popup core CSS file -->
	<link rel="stylesheet" href="css/magnific-popup.css"> 
	
	<script src="js/modernizr-2.8.3.min.js"></script>  <!-- Modernizr /-->
	<!--[if IE 9]>
		<script src="js/PIE_IE9.js"></script>
	<![endif]-->
	<!--[if lt IE 9]>
		<script src="js/PIE_IE678.js"></script>
	<![endif]-->

	<!--[if lt IE 9]>
		<script src="js/html5shiv.js"></script>
	<![endif]-->
	
	
	

</head>

<body id="home">

	<!-- Preloader -->
	<div id="preloader">
		<div id="status"></div>
	</div>
	
	<!-- FullScreen -->
    <!--<div class="intro-header">
		<div class="col-xs-12 text-center abcen1">
			<h1 class="h1_home wow fadeIn" data-wow-delay="0.4s">Flatfy</h1>
			<h3 class="h3_home wow fadeIn" data-wow-delay="0.6s">Clean & minimal Theme</h3>
			<ul class="list-inline intro-social-buttons">
				<li><a href="https://twitter.com/galantiandrea" class="btn  btn-lg mybutton_cyano wow fadeIn" data-wow-delay="0.8s"><span class="network-name">Twitter</span></a>
				</li>
				<li id="download" ><a href="#downloadlink" class="btn  btn-lg mybutton_standard wow swing wow fadeIn" data-wow-delay="1.2s"><span class="network-name">Free Download</span></a>
				</li>
			</ul>
		</div>    
        <!-- /.container -->
		<div class="col-xs-12 text-center abcen wow fadeIn">
			<div class="button_down "> 
				<a class="imgcircle wow bounceInUp" data-wow-duration="1.5s"  href="#whatis"> <img class="img_scroll" src="img/icon/circle.png" alt=""> </a>
			</div>
		</div>
    </div>
	
	<!-- NavBar-->
	<nav class="navbar-default" role="navigation">
		<div class="container">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
					<span class="sr-only">Toggle navigation</span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="#home">REA-AED</a>
			</div>

			<div class="collapse navbar-collapse navbar-right navbar-ex1-collapse">
				<ul class="nav navbar-nav">
					
					<li class="menuItem"><a href="index.html">Home</a></li>
					<ul class="nav navbar-nav navbar-right">
						<li class="dropdown">
						  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Aulas<span class="caret"></span></a>
						  <ul class="dropdown-menu">
							<li><a href="aula_cb.html">Conceitos Básicos</a></li>
							<li><a href="aula_seq.html">Estrutura Sequencial</a></li>
							<li><a href="aula_cond.html">Estrutura Condicional</a></li>
							<li><a href="aula_rep.html">Estrutura de Repetição</a></li>
							<li><a href="aula_vet.html">Vetores</a></li>
							<li><a href="aula_mat.html">Matrizes</a></li>
							<li><a href="aula_func.html">Procedimentos e Funções</a></li>
							<li><a href="aula_reg.html">Registros</a></li>
							<li><a href="aula_rec.html">Recursividade</a></li>
							<li><a href="aula_pon.html">Ponteiros</a></li>
							<li><a href="aula_aloc.html">Alocação Dinâmica</a></li>
							<li><a href="aula_arq.html">Arquivos</a></li>
							<li><a href="aula_list.html" style= "color:#04B486">Listas</a></li>
							<li><a href="aula_pilha_fila.html">Pilha e Fila</a></li>
							<li><a href="aula_arv.html">Árvore Binária</a></li>
							<li role="separator" class="divider"></li>
						  </ul>
						</li>
						<li class="menuItem"><a href="biblio.html">Bibliografia</a></li>
					</ul>
				</ul>
			</div>
		   
		</div>
	</nav> 
	
	<!-- What is -->
	<div id="whatis" class="content-section-a" style="border-top: 0">
		<div class="container">
			<div class="col-md-8 col-md-offset-2 text-center wrap_title">
				<h2>Listas</h2>
				<p class="lead" style="margin-top:0">O objetivo dessa unidade é apresentar o conteúdo relacionado a Listas. Será feita
				uma abordagem focando na linguagem C.</p>
			</div>
			<div class="col-md-10 col-md-offset-1  wrap_title">
				<div class="row">
					<h3>Introdução</h3>
					<p align="justify">Até agora temos trabalhado com estruturas de dados, das mais simples às mais complexas, que têm tamanho fixo. Por esta razão, denominam-se estruturas de dados estáticas (o seu tamanho e localização na memória não se alteram durante a execução).</p>
					<p align="justify">Pois bem, agora vamos unir as estruturas estáticas juntamente com a alocação dinâmica e usar esses poderosos conceitos para criar outro importante, o de estruturas de dados dinâmicas, ou seja, as estruturas de dados que são alocadas, realocadas e movidas o quanto e do jeito que quisermos.</p>
					<p>A partir daí, poderemos trabalhar com conjuntos de dados dinâmicos, com por exemplo uma coleção de números, dados de um funcionário, dados de um produto, entre outros. O que difere esses dados dos demais é a necessidade de manipulações que faça com que eles possam crescer, encolher, sofrer alterações ao logo da execução de determinado programa.</p>
					<p>A primeira estrutura dinâmica que iremos estudar são as listas.</p>
				</div>
				<div class="row">
					<h3>Listas Simplesmente Encadeadas</h3>
						<p align="justify">Uma lista encadeada é uma estrutura de dados que representa um conjunto de dados organizados em ordem linear e dinâmica. Ela é composta por células também chamadas de nós (aqui adotaremos essa nomenclatura), que utilizando um ponteiro apontam para o próximo elemento da lista, e seu último elemento aponta para NULL, sinalizando que não existe um próximo elemento. Para que uma lista encadeada exista, basta guardar seu primeiro elemento. O primeiro é ligado no segundo, que é ligado no terceiro etc.</p>
						<p>Numa lista encadeada, para cada novo elemento inserido na estrutura, alocamos um espaço de memória para armazená-lo. Desta forma, o espaço total de memória gasto pela estrutura é proporcional ao número de elementos nela armazenado. No entanto, não podemos garantir que os elementos armazenados na lista ocuparão um espaço de memória contíguo, portanto não temos acesso direto aos elementos da lista. Para que seja possível percorrer todos os elementos da lista, devemos explicitamente guardar o encadeamento dos elementos, o que é feito armazenando-se, junto com a informação de cada elemento, um ponteiro para o próximo elemento da lista</p>
						<h4>Primeiros passos para a construção de uma lista simplesmente encadeada</h4>
						<p>Para representarmos um elemento da lista simplesmente encadeada (um nó) vamos utilizar uma struct, que chamaremos de No. Vejamos:</p>
						<pre>
<span class="blue">struct</span> No{
    <span class="blue">int</span> num;
    <span class="blue">struct</span> No *prox;
};
<span class="green">typedef</span> <span class="blue">struct</span> No No;</pre>
						<p>Cada nó de uma lista simplesmente encadeada irá possuir pelo menos (pode ser mais de um) um atributo que corresponde  a determinado dado a ser armazenado pela lista (int, float, char, struct..) e um ponteiro (do tipo No) que será utilizado para armazenar o endereço de memória do próximo nó (dessa maneira "ligamos" um nó a outro nó). Aqui utilizaremos uma lista para armazenar inteiros (int num) e o ponteiro do tipo No que apontará para o próximo nó sera *prox.</p>
						<p>Para o controle da lista utilizaremos uma estrutura do tipo Lista. Ela contém dois ponteiros do tipo No (inicio e fim), que irão armazenar os endereço de memória do primeiro e do último elemento da lista respectivamente.</p>
						<pre>
<span class="com">/*registro do tipo Lista contento dois ponteiros do tipo nó para controlar a lista*/</span>
<span class="blue">struct</span> Lista{
    <span class="blue">struct</span> No *inicio; <span class="com">/*aponta para o elemento do início da lista*/</span>
    <span class="blue">struct</span> No *fim; <span class="com">/*aponta para o elemento do fim da lista*/</span>
};
<span class="green">typedef</span> <span class="blue">struct</span> Lista Lista;</pre>
						<p>Para auxiliar em algumas funções, é necessário utilizar dois ponteiros auxiliares do tipo No. Então definimos abaixo: </p>
						<pre>
<span class="com">/*necessitaremos também de dois ponteiros auxilares *aux e *anterior */</span>
No *aux;
No *anterior;</pre>
						<p>Nesse ponto definiremos também uma função cria_lista( ). Ela será utilizada para criar uma lista, ou seja, alocará dinamicamente o espaço necessário para armazenar seus ponteiros (inicio e fim ) e irá inicializá-los com NULL. Isso indica que a lista inicialmente está vazia.</p>
						<pre>
Lista* cria_lista(){
    /*alocação do ponteiro li para controlar a lista*/
    Lista* li = (Lista*) malloc(<span class="green">sizeof</span>(Lista));
    if(li != <span class="green">NULL</span>){
       <span class="com"> /*Se a lista está inicialmente vazia, inicio e fim apontam para NULL */</span>
        li->fim = <span class="green">NULL</span>;
        li->inicio = <span class="green">NULL</span>;
    }
    <span class="green">return</span> li;
}</pre>
						<p>Na função main, devemos definir um ponteiro do tipo Lista. Ele irá receber o endereço do espaço alocado pela função cria_lista( ) e também servirá de parâmetro para as demais funções seguintes. </p>
						<pre>
<span class="blue">int </span>main(){
    Lista *li = cria_lista();
	 <span class="com">...blocos de chamada de função...</span>
    <span class="green">return</span> <span class="number">0</span>;
}</pre>
				</div>
				<div class="row">
					<h3>Lista simplesmente encadeada e não ordenada</h3>
					<p align="justify">Como o próprio nome descreve é uma lista simplesmente encadeada em que não há qualquer tipo de ordenação em relação aos nós pertencentes à lista.  A disposição dos mesmos dependerá da ordem e local (início ou fim da lista) em que forem inseridos.</p>
					<p>Para este tipo de lista realizaremos 5 operações:</p>
					<ul style="list-style-type:circle">
							<li>Inserção no início da lista;</li>
							<li>Inserção no fim da lista;</li>
							<li>Impressão da lista;</li>
							<li>Remoção de elemento da lista;</li>
							<li>Esvaziar lista;</li>
					</ul>
					<h4>Inserção no início da lista</h4>
					<p>Esta é a implementação da função que utilizaremos para inserir um dado no início da lista.</p>
					<pre>
<span class="blue">void</span> insere_inicio_lista(Lista *li){
    <span class="com">/*a cada inserção alocamos dinamicamente um espaço para um novo nó*/</span>
    No *novo =(No*) malloc(<span class="green">sizeof</span>(No));
     <span class="com">/*o número a ser inserido será armazenado em novo->num*/</span>
    printf(<span class="text">"Digite o numero a ser inserido no inicio da lista: "</span>);
    scanf(<span class="text">"%d"</span>,&novo->num);
     <span class="com">/*caso a lista estiver vazia o primeiro elemento a ser inserido será o primeiro e último*/</span>
    <span class="green">if</span>(li->inicio == <span class="green">NULL</span>){
         <span class="com">/*aqui fazemos com que inicio aponte para o mesmo endereço que novo aponta*/</span>
        li->inicio = novo;
        novo->prox = <span class="green">NULL</span>;
         <span class="com">/*aqui fazemos com que fim aponte para o mesmo endereço que novo aponta*/</span>
        li->fim = novo;
     <span class="com">/*caso a lista não esteja vazia*/</span>
    }<span class="green">else</span>{
         <span class="com">/*como a inserção é no inicio, o novo nó inserido receberá no atributo prox o endereço que inicio aponta, ou seja,
         o inicio anterior será agora o segundo elemento, portante o primeiro elemento da lista terá que apontar para ele*/</span>
        novo->prox = li->inicio;
         <span class="com">/*aqui fazemos com que inicio aponte para o mesmo endereço do novo nó inserido*/</span>
        li->inicio = novo;
    }
    printf(<span class="text">"\nNumero inserido no inicio da lista!"</span>);
    getch();
}
					</pre>
					<p>Na prática isso aconteceria da seguinte maneira:</p>
					<p>Inicialmente temos os ponteiros inicio e fim apontados para null: </p>
					<div class="row"><center><img class="img-responsive " src="img/list/inicio_lista.PNG" alt="" align="middle"><center></div>
					<p>Agora inseriremos o número 3 no início da lista.</p>
					<div class="row"><center><img class="img-responsive " src="img/list/insere1.PNG" alt="" align="middle"><center></div>
					<p>Depois vamos inserir o número 9 no início da lista.</p>
					<div class="row"><center><img class="img-responsive " src="img/list/insere2.PNG" alt="" align="middle"><center></div>
					
					<h4>Inserção no fim da lista</h4>
					<p>Agora trataremos de inserir dados no fim da lista. Vejamos a implementação:</p>
					<pre>
<span class="blue">void</span> insere_fim_lista(Lista *li){
     <span class="com">/*a cada inserção alocamos dinamicamente um espaço para um novo nó*/</span>
    No *novo =(No*) malloc(<span class="green">sizeof</span>(No));
     <span class="com">/*o número a ser inserido será armazenado em novo->num*/</span>
    printf(<span class="text">"Digite o numero a ser inserido no fim da lista: "</span>);
    scanf(<span class="text">"%d"</span>,&novo->num);
    <span class="com"> /*caso a lista estiver vazia o primeiro elemento a ser inserido será o primeiro e último*/</span>
    <span class="green">if</span>(li->inicio == <span class="green">NULL)</span>{
         <span class="com">/*aqui fazemos com que inicio aponte para o mesmo endereço que novo aponta*/</span>
        li->inicio = novo;
		novo->prox = <span class="green">NULL</span>;
        /*aqui fazemos com que fim aponte para o mesmo endereço que novo aponta*/</span>
        li->fim = novo;
        <span class="com">/*caso a lista não esteja vazia*/</span>
    }<span class="green">else</span>{
         <span class="com">/*como a inserção é no fim, o nó para o qual fim aponta, no atributo prox, receberá o endereço de novo, ou seja,
          o último elemento será agora o penúltimo, e portanto deverá apontar para o último elemento inseirido*/</span>
        li->fim->prox = novo;
         <span class="com">/*aqui fazemos com que fim aponte para o mesmo do novo nó inserido*/</span>
        li->fim = novo;
         <span class="com">/*aqui fazemos com que o endereço para o qual fim aponta, no atributo prox receba NULL*/</span>
        li->fim->prox = <span class="green">NULL</span>;
    }
    printf(<span class="text">"\nNumero inserido no fim da lista!"</span>);
    getch();
}
					</pre>
					<p>Complementando a lista iniciada anteriormente, vamos inserir o número 6 no final da lista:</p>
					<div class="row"><center><img class="img-responsive " src="img/list/insere3.PNG" alt="" align="middle"><center></div>
					<p>Por fim, vamos inserir o número 2 no final da lista:</p>
					<div class="row"><center><img class="img-responsive " src="img/list/insere4.PNG" alt="" align="middle"><center></div>
					
					<h4>Impressão da lista</h4>
					<p>Para imprimir os elementos da lista (do início para o fim), utilizaremos a seguinte função: </p>
					<pre>
<span class="blue">void</span> imprime_lista(Lista *li){
     <span class="com">/*caso a lista esteja vazia*/!!"</span>);
    <span class="green">if</span>(li->inicio == <span class="green">NULL</span>){
        printf(<span class="text">"\nLista Vazia!!"</span>);
     <span class="com">/*caso a lista não esteja vazia*/</span>
    }<span class="green">else</span>{
        <span class="com"> /*utilizando o ponteiro aux,  fazemos com ele aponte para o mesmo endereço que inicio aponta*/</span>
        aux = li->inicio;
        <span class="green">do</span>{
             <span class="com">/*impressão do elemento que aux aponta*/</span>
            printf(<span class="text">" %d "</span>, aux->num);
             <span class="com">//*aux aponta para o próximo elemento da lista, que será o endereço contido no ponteiro prox.*/</span>
            aux = aux->prox;
        <span class="com"> /*essa operação será feita até aux ser diferente de NULL, ou seja, não houverem mais elementos a serem impressos*/</span>
        }<span class="green">while</span>(aux != <span class="green">NULL</span>);
    }
    getch();
}
					</pre>
					<p>A saída seria: 9   3   6   2.</p>
					<h4>Remoção de elemento da lista</h4>
					<p>Para removermos um determinado elemento da lista, utilizaremos a seguinte função:</p>
					<pre>
<span class="blue">void</span> remover_elemento(Lista *li){
    <span class="blue">int</span> numero;
    <span class="com">/*a variável achou será utilizada como um contador de números removidos*/</span>
    <span class="blue"> int</span> achou;
    <span class="com">/*caso a lista esteja vazia*/</span>
    <span class="green">if</span>(li->inicio ==<span class="green"> NULL</span>){
        printf(<span class="text">"\nLista Vazia!!"</span>);
    <span class="com">/*caso a lista não esteja vazia*/</span>
    }<span class="green">else</span>{
        printf(<span class="text">"Digite o elemento a ser removido: "</span>);
        scanf(<span class="text">"%d"</span>, &numero);
        <span class="com">/*utilizando o ponteiro aux,  fazemos com ele aponte para o mesmo endereço que inicio aponta*/</span>
        aux = li->inicio;
        <span class="com">/*utilizando o ponteiro ele,  fazemos com ele aponte para NULL*/</span>
        anterior = <span class="green">NULL</span>;
        achou = <span class="number">0</span>;
        <span class="green">do</span>{
            <span class="com">/*caso aux-> num seja igual ao número a ser removido*/</span>
            <span class="green">if</span>(aux->num == numero){
                <span class="com">/*incrementamos achou*/</span>
                achou = achou + <span class="number">1</span>;
                <span class="com">/*se o elemento a ser removido for o primeiro da lista*/</span>
                <span class="green">if</span>(aux == li->inicio){
                   <span class="com"> /*inicio apontará para o segundo elemento da lista ou para NULL
                      caso o elemento removido seja o único elemento da lista*/</span>
                    li->inicio = aux ->prox;
                   <span class="com"> /*desalocamos o espaço para onde aux apontava*/</span>
                    free(aux);
                   <span class="com"> /*aux aponta para o inicio da lista*/</span>
                    aux = li->inicio;
               <span class="com"> /*se o elemento a ser removido for o último da lista*/</span>
                }<span class="green">else if</span> (aux == li->fim){
                   <span class="com"> /*o elemento anterior a fim, no atributo prox apontará para NULL*/</span>
                    anterior->prox = <span class="green">NULL</span>;
                    <span class="com"> /*fim aponta para o elemento apontado por anterior*/</span>
                    li->fim = anterior;
                    <span class="com">/*desalocamos o espaço para onde aux apontava*/</span>
                    free(aux);
                    <span class="com">/*como era o últmo elemento da lista, aux recebe NULL*/</span>
                    aux = <span class="green">NULL</span>;
                <span class="com">/*se o elemento a ser removido não for nem o primeiro nem o último da lista */</span>
                }<span class="green">else</span>{
                   <span class="com"> /*o elemento anterior ao elemento a ser removido, no atributo prox apontará para o elemento
                      para qual aux->prox apontava*/</span>
                    anterior->prox = aux->prox;
                    <span class="com">/*desalocamos o espaço para onde aux apontava*/</span>
                    free(aux);
                    <span class="com">/*aux aponta para o próximo elemento da lista, aquele que era o seguinte ao número removido*/</span>
                    aux = anterior -> prox;
                }
				 <span class="com">/*caso aux-> num não seja igual ao número a ser removido*/</span>
				 }<span class="green">else</span>{
				     anterior = aux;
				     aux = aux -> prox;
				 }
        <span class="com">/*essa operação será feita até aux ser diferente de NULL, ou seja, não houverem mais elementos a serem pesquisados*/</span>
        }<span class="green">while</span>(aux != <span class="green">NULL</span>);
         <span class="com">/*impressão do resultado*/</span>
        <span class="green">if</span>(achou == <span class="number">0</span>){
            printf(<span class="text">"Numero nao encontrado!"</span>);
        }<span class="green">else</span>{
            printf(<span class="text">"Numero removido %d vez(es)"</span>,achou);
        }
    }
    getch();
}			</pre>
					<p>Com base na lista criada anteriormente, faremos algumas remoções: </p>
					<div class="row"><center><img class="img-responsive " src="img/list/insere4.PNG" alt="" align="middle"><center></div>
					<p>Primeiramente, vamos remover o número 3:</p>
					<div class="row"><center><img class="img-responsive " src="img/list/remove1.PNG" alt="" align="middle"><center></div>
					<p>E depois removeremos o número 9.</p>
					<div class="row"><center><img class="img-responsive " src="img/list/remove2.PNG" alt="" align="middle"><center></div>
					<h4>Esvaziar lista</h4>
					<p>Nesta última operação esvaziaremos a nossa lista, isto significa remover todos os seus nós restantes desalocando o espaço reservado para cada um. Esta é a implementação utilizada:</p>
					<pre>
<span class="blue">void</span> esvaziar_lista(Lista *li){
     <span class="com">/*caso a lista esteja vazia*/</span>
    <span class="green">if</span>(li->inicio == <span class="green">NULL</span>){
        printf(<span class="text">"\nLista Vazia!!"</span>);
     <span class="com">/*caso a lista não esteja vazia*/</span>
    }<span class="green">else</span>{
        <span class="com"> /*utilizando o ponteiro aux,  fazemos com ele aponte para o mesmo endereço de inicio  aponta*/</span>
        aux = li->inicio;
        <span class="green">do</span>{
            <span class="com"> /*inicio apontará para o próximo elemento da lista*/</span>
            li->inicio = li->inicio->prox;
             <span class="com">/*desalocamos o espaço para onde aux apontava*/</span>
            free(aux);
            <span class="com"> /*aux apontará para o mesmo endereço que inicio aponta*/</span>
            aux = li->inicio;
          <span class="com">/*essa operação será feita até aux ser diferente de NULL, ou seja, não houverem mais elementos a serem removidos*/</span>
        }<span class="green">while</span>(aux != <span class="green">NULL</span>);
        printf(<span class="text">"\nLista Esvaziada!!"</span>);
    }
    getch();
}</pre>
					<p>O resultado final após essa operação seria esse:</p>
					<div class="row"><center><img class="img-responsive " src="img/list/inicio_lista.PNG" alt="" align="middle"><center></div>
				</div>
				
				<div class="row">
					<h3>Lista simplesmente encadeada e ordenada</h3>
					<p align="justify">A diferença desse tipo de lista simplesmente encadeada é que ela utiliza determinado dado armazenado como parâmetro para a ordenação da lista. No nosso caso utilizaremos "num" para ordenar nossa lista de maneira crescente.</p>
					<p>Para este tipo de lista realizaremos 4 operações:</p>
					<ul style="list-style-type:circle">
							<li>Inserção na lista;</li>
							<li>Impressão da lista;</li>
							<li>Remoção de elemento da lista;</li>
							<li>Esvaziar lista;</li>
					</ul>
					<h4>Inserção na lista</h4>
					<p>Esta é a implementação da função que utilizaremos para inserir um dado no início da lista.</p>
					<pre>
<span class="blue">void</span> insere_lista(Lista *li){
    <span class="com">/*a cada inserção alocamos dinamicamente um espaço para um novo nó*/</span>
    No *novo =(No*) malloc(<span class="green">sizeof</span>(No));
    <span class="com">/*o número a ser inserido será armazenado em novo->num*/</span>
    printf(<span class="text">"\nDigite o no a ser inserido na lista: "</span>);
    scanf(<span class="text">"%d",</span>&novo->num);
    <span class="com">/*caso a lista estiver vazia o primeiro elemento a ser inserido será o primeiro e último*/</span>
   <span class="green">if</span>(li->inicio == <span class="green">NULL</span>){
        li->inicio = novo;  <span class="com">/*aqui fazemos com que inicio aponte para o mesmo endereço que novo aponta*/</span>
        li->fim = novo;  <span class="com">/*aqui fazemos com que fim aponte para o mesmo endereço que novo aponta*/</span>
        li->fim->prox = NULL;  <span class="com">/*aqui fazemos com que o endereço para o qual fim aponta, no atributo prox receba NULL*/</span>
   <span class="com"> /*caso a lista não esteja vazia*/</span>
    }<span class="green">else</span>{
        anterior = <span class="green">NULL</span>;  <span class="com">/*inicialmente anterior apontará para NULL*/</span>
        aux = li->inicio; <span class="com">/*aux aponta para o primeiro elemento da lista*/</span>
        <span class="com">/*enquanto aux apontar para um nó existente  e o número inserido for maior que o número apontado por aux,
        a variação do valor de aux fará com que o novo número possa ser inseirido no local adequado, que é antes de um número maior que ele.*/</span>
        <span class="green">while</span>(aux !=<span class="green">NULL</span> && novo->num > aux->num){
            anterior = aux;  <span class="com">/*anterior aponta para o endereço que aux aponta*/</span>
            aux = aux->prox;   <span class="com">/*aux aponta para o próximo nó da lista*/</span>
        }
        <span class="com">/*caso não exista nenhum número menor que o novo número*/</span>
       <span class="green">if</span>(anterior ==<span class="green"> NULL</span>){
            novo->prox = li->inicio;  <span class="com">/*o novo elemento no atributo prox, apontará para o elemento que até então era o primeiro elemento da lista*/</span>
            li->inicio = novo;  <span class="com">/*novo será o primeiro elemento da lista, inicio apontará para o endereço de novo*/</span>
        <span class="com">/*caso não exista nenhum número maior que o novo número*/</span>
        }<span class="green">else if</span>(aux == <span class="green">NULL</span>){
            li->fim->prox = novo;  <span class="com">/*o até então ultimo elemento da lista no atributo prox apontará para novo*/</span>
            li->fim = novo; <span class="com">/*novo será o ultimo elemento da lista, fim apontará para o endereço de novo*/</span>
            li->fim->prox = <span class="green">NULL</span>; <span class="com">/*aqui fazemos com que o endereço para o qual fim aponta, no atributo prox receba NULL*/</span>
        <span class="com">/*caso número precise ser inseirido no meio da lista*/</span>
        }<span class="green">else</span>{
            anterior->prox = novo; <span class="com">/*o primeiro número menor que o novo inseirido no atributo prox recebe o endereço de novo*/</span>
            novo->prox = aux; <span class="com">/*novo no atibuto prox, recebe o endereço do primeiro número maior que ele*/</span>
        }
    }
    printf(<span class="text">"\nNumero inserido na lista!"</span>);
    getch();
}</pre>
					<p>Na prática isso aconteceria da seguinte maneira:</p>
					<p>Inicialmente temos os ponteiros inicio e fim apontados para null: </p>
					<div class="row"><center><img class="img-responsive " src="img/list/inicio_lista.PNG" alt="" align="middle"><center></div>
					<p>Primeiro: inseriremos o número 3 na lista.</p>
					<div class="row"><center><img class="img-responsive " src="img/list/insere_seo1.PNG" alt="" align="middle"><center></div>
					<p>Segundo: inseriremos o número 9 na lista.</p>
					<div class="row"><center><img class="img-responsive " src="img/list/insere_seo2.PNG" alt="" align="middle"><center></div>
					<p>Terceiro: inseriremos o número 6 na lista.</p>
					<div class="row"><center><img class="img-responsive " src="img/list/insere_seo3.PNG" alt="" align="middle"><center></div>
					<p>Quarto: inseriremos o número 2 na lista.</p>
					<div class="row"><center><img class="img-responsive " src="img/list/insere_seo4.PNG" alt="" align="middle"><center></div>
					<h4>Impressão da lista</h4>
					<p>Para imprimir os elementos da lista (do início para o fim), utilizaremos a seguinte função: </p>
					<pre>
<span class="blue">void</span> imprime_lista(Lista *li){
     <span class="com">/*caso a lista esteja vazia*/!!"</span>);
    <span class="green">if</span>(li->inicio == <span class="green">NULL</span>){
        printf(<span class="text">"\nLista Vazia!!"</span>);
     <span class="com">/*caso a lista não esteja vazia*/</span>
    }<span class="green">else</span>{
        <span class="com"> /*utilizando o ponteiro aux,  fazemos com ele aponte para o mesmo endereço que inicio aponta*/</span>
        aux = li->inicio;
        <span class="green">do</span>{
             <span class="com">/*impressão do elemento que aux aponta*/</span>
            printf(<span class="text">" %d "</span>, aux->num);
             <span class="com">//*aux aponta para o próximo elemento da lista, que será o endereço contido no ponteiro prox.*/</span>
            aux = aux->prox;
        <span class="com"> /*essa operação será feita até aux ser diferente de NULL, ou seja, não houverem mais elementos a serem impressos*/</span>
        }<span class="green">while</span>(aux != <span class="green">NULL</span>);
    }
    getch();
}</pre>
					<p>A saída seria: 2   3   6   9.</p>
					<h4>Remoção de elemento da lista</h4>
					<p>Para removermos um determinado elemento da lista, utilizaremos a seguinte função:</p>
					<pre>
<span class="blue">void</span> remover_elemento(Lista *li){
    <span class="blue">int</span> numero;
    <span class="com">/*a variável achou será utilizada como um contador de números removidos*/</span>
    <span class="blue"> int</span> achou;
    <span class="com">/*caso a lista esteja vazia*/</span>
    <span class="green">if</span>(li->inicio ==<span class="green"> NULL</span>){
        printf(<span class="text">"\nLista Vazia!!"</span>);
    <span class="com">/*caso a lista não esteja vazia*/</span>
    }<span class="green">else</span>{
        printf(<span class="text">"Digite o elemento a ser removido: "</span>);
        scanf(<span class="text">"%d"</span>, &numero);
        <span class="com">/*utilizando o ponteiro aux,  fazemos com ele aponte para o mesmo endereço que inicio aponta*/</span>
        aux = li->inicio;
        <span class="com">/*utilizando o ponteiro ele,  fazemos com ele aponte para NULL*/</span>
        anterior = <span class="green">NULL</span>;
        achou = <span class="number">0</span>;
        <span class="green">do</span>{
            <span class="com">/*caso aux-> num seja igual ao número a ser removido*/</span>
            <span class="green">if</span>(aux->num == numero){
                <span class="com">/*incrementamos achou*/</span>
                achou = achou + <span class="number">1</span>;
                <span class="com">/*se o elemento a ser removido for o primeiro da lista*/</span>
                <span class="green">if</span>(aux == li->inicio){
                   <span class="com"> /*inicio apontará para o segundo elemento da lista ou para NULL
                      caso o elemento removido seja o único elemento da lista*/</span>
                    li->inicio = aux ->prox;
                   <span class="com"> /*desalocamos o espaço para onde aux apontava*/</span>
                    free(aux);
                   <span class="com"> /*aux aponta para o inicio da lista*/</span>
                    aux = li->inicio;
               <span class="com"> /*se o elemento a ser removido for o último da lista*/</span>
                }<span class="green">else if</span> (aux == li->fim){
                   <span class="com"> /*o elemento anterior a fim, no atributo prox apontará para NULL*/</span>
                    anterior->prox = <span class="green">NULL</span>;
                    <span class="com"> /*fim aponta para o elemento apontado por anterior*/</span>
                    li->fim = anterior;
                    <span class="com">/*desalocamos o espaço para onde aux apontava*/</span>
                    free(aux);
                    <span class="com">/*como era o últmo elemento da lista, aux recebe NULL*/</span>
                    aux = <span class="green">NULL</span>;
                <span class="com">/*se o elemento a ser removido não for nem o primeiro nem o último da lista */</span>
                }<span class="green">else</span>{
                   <span class="com"> /*o elemento anterior ao elemento a ser removido, no atributo prox apontará para o elemento
                      para qual aux->prox apontava*/</span>
                    anterior->prox = aux->prox;
                    <span class="com">/*desalocamos o espaço para onde aux apontava*/</span>
                    free(aux);
                    <span class="com">/*aux aponta para o próximo elemento da lista, aquele que era o seguinte ao número removido*/</span>
                    aux = anterior -> prox;
                }
				 <span class="com">/*caso aux-> num não seja igual ao número a ser removido*/</span>
				 }<span class="green">else</span>{
				     anterior = aux;
				     aux = aux -> prox;
				 }
        <span class="com">/*essa operação será feita até aux ser diferente de NULL, ou seja, não houverem mais elementos a serem pesquisados*/</span>
        }<span class="green">while</span>(aux != <span class="green">NULL</span>);
         <span class="com">/*impressão do resultado*/</span>
        <span class="green">if</span>(achou == <span class="number">0</span>){
            printf(<span class="text">"Numero nao encontrado!"</span>);
        }<span class="green">else</span>{
            printf(<span class="text">"Numero removido %d vez(es)"</span>,achou);
        }
    }
    getch();
}</pre>
					<p>Com base na lista criada anteriormente, faremos algumas remoções: </p>
					<div class="row"><center><img class="img-responsive " src="img/list/insere_seo4.PNG" alt="" align="middle"><center></div>
					<p>Vamos então remover o número 6:</p>
					<div class="row"><center><img class="img-responsive " src="img/list/remove_seo1.PNG" alt="" align="middle"><center></div>
					<p>Também removeremos o número 2.</p>
					<div class="row"><center><img class="img-responsive " src="img/list/remove_seo2.PNG" alt="" align="middle"><center></div>
					<p>Por fim removeremos o número 9.</p>
					<div class="row"><center><img class="img-responsive " src="img/list/insere_seo1.PNG" alt="" align="middle"><center></div>
					<h4>Esvaziar lista</h4>
					<p>Nesta última operação esvaziaremos a nossa lista, isto significa remover todos os seus nós restantes desalocando o espaço reservado para cada um. Esta é a implementação utilizada:</p>
					<pre>
<span class="blue">void</span> esvaziar_lista(Lista *li){
     <span class="com">/*caso a lista esteja vazia*/</span>
    <span class="green">if</span>(li->inicio == <span class="green">NULL</span>){
        printf(<span class="text">"\nLista Vazia!!"</span>);
     <span class="com">/*caso a lista não esteja vazia*/</span>
    }<span class="green">else</span>{
        <span class="com"> /*utilizando o ponteiro aux,  fazemos com ele aponte para o mesmo endereço de inicio  aponta*/</span>
        aux = li->inicio;
        <span class="green">do</span>{
            <span class="com"> /*inicio apontará para o próximo elemento da lista*/</span>
            li->inicio = li->inicio->prox;
             <span class="com">/*desalocamos o espaço para onde aux apontava*/</span>
            free(aux);
            <span class="com"> /*aux apontará para o mesmo endereço que inicio aponta*/</span>
            aux = li->inicio;
          <span class="com">/*essa operação será feita até aux ser diferente de NULL, ou seja, não houverem mais elementos a serem removidos*/</span>
        }<span class="green">while</span>(aux != <span class="green">NULL</span>);
        printf(<span class="text">"\nLista Esvaziada!!"</span>);
    }
    getch();
}</pre></pre>
					<p>O resultado final após essa operação seria esse:</p>
					<div class="row"><center><img class="img-responsive " src="img/list/inicio_lista.PNG" alt="" align="middle"><center></div>
				</div>
			<center>
				<h3>Video Explicativo - Listas Simplesmente Encadeadas</h3>
					<p>                                      </p>
					<video width=80% height="315" class="img-responsive" controls>
					  <source src="video/listas_se.mp4" type="video/mp4">
					  <source src="movie.ogg" type="video/ogg">
					  Your browser does not support the video tag.
					</video>
				</center>
			<div class="row">
					<h3>Listas Duplamente Encadeadas</h3>
						<p align="justify">Assim como as listas simplesmente encadeadas, uma lista duplamente encadeada é uma estrutura de dados que representa um conjunto de dados organizados em ordem linear e dinâmica. Ela também é composta por células ou nós (nomenclatura adotada), no entanto, a conexão entre os seus elementos é feita através de dois ponteiros (um que aponta para o elemento anterior, e o outro, para o seguinte).</p>
						<p>Numa lista duplamente encadeada, para cada novo elemento inserido na estrutura, alocamos um espaço de memória para armazená-lo. Desta forma, o espaço total de memória gasto pela estrutura é proporcional ao número de elementos nela armazenado. No entanto, não podemos garantir que os elementos armazenados na lista ocuparão um espaço de memória contíguo, portanto não temos acesso direto aos elementos da lista. Para que seja possível percorrer todos os elementos da lista, devemos explicitamente guardar o encadeamento dos elementos, o que é feito armazenando-se, junto com a informação de cada elemento, um ponteiro para o próximo elemento da lista e um ponteiro para o elemento anterior.</p>
						<p>Características a destacar: </p>
						<ul style="list-style-type:circle">
							<li>O ponteiro anterior do primeiro elemento deve apontar para NULL (o início da lista);</li>
							<li>O ponteiro próximo do último elemento deve apontar para NULL (o fim da lista). </li>
							<li>Para acessar um elemento, a lista pode ser percorrida pelos dois lados.</li>
					     </ul>
						<h4>Primeiros passos para a construção de uma lista duplamente encadeada</h4>
						<p>Para representarmos um elemento da lista (um nó) vamos utilizar uma struct, que chamaremos de No. Vejamos:</p>
						<pre>
<span class="blue">struct</span> No{
    <span class="blue">int</span> num;
    <span class="blue">struct</span> No *prox;
   <span class="blue"> struct</span> No *ant;
};
<span class="green">typedef</span> <span class="blue">struct</span> No No;</pre>
						<p>Cada nó de uma lista duplamente encadeada irá possuir pelo menos (pode ser mais de um) um atributo que corresponde determinado dado a ser armazenado pela lista (int, float, char, struct..), um ponteiro (do tipo No) *prox que será utilizado para armazenar o endereço de memória do próximo nó e outro ponteiro (do tipo No) *ant que será utilizado para armazenar o endereço de memória do nó anterior (dessa maneira "ligamos" duas vezes um nó a outro nó). Aqui utilizaremos uma lista para armazenar inteiros (int num).</p>
						<p>Para o controle da lista utilizaremos uma estrutura do tipo Lista. Ela contém dois ponteiros do tipo No (inicio e fim), que irão armazenar os endereço de memória do primeiro e do último elemento da lista respectivamente.</p>
						<pre>
<span class="com">/*registro do tipo Lista contento dois ponteiros do tipo nó para controlar a lista*/</span>
<span class="blue">struct</span> Lista{
    <span class="blue">struct</span> No *inicio; <span class="com">/*aponta para o elemento do início da lista*/</span>
    <span class="blue">struct</span> No *fim; <span class="com">/*aponta para o elemento do fim da lista*/</span>
};
<span class="green">typedef</span> <span class="blue">struct</span> Lista Lista;</pre>
						<p>Para auxiliar em algumas funções, é necessário utilizar três ponteiros auxiliares do tipo No. Então definimos abaixo:</p>
						<pre>
<span class="com">/*necessitaremos também de três ponteiros auxilares *aux , *aux2 e *anterior */</span>
No *aux;
No *aux2;
No *anterior;</pre>
						<p>Nesse ponto definiremos também uma função cria_lista( ). Ela será utilizada para criar uma lista, ou seja, alocará dinamicamente o espaço necessário para armazenar seus ponteiros (inicio e fim ) e irá inicializá-los com NULL. Isso indica que a lista inicialmente está vazia.</p>
						<pre>
Lista* cria_lista(){
    <span class="com">/*alocação do ponteiro li para controlar a lista*/</span>
    Lista* li = (Lista*) malloc(<span class="green">sizeof</span>(Lista));
    <span class="green">if</span>(li != <span class="green">NULL</span>){
        <span class="com">/*Se a lista está inicialmente vazia, inicio e fim apontam para NULL */</span>
        li->fim = <span class="green">NULL</span>;
        li->inicio = <span class="green">NULL</span>;
    }
    <span class="green">return</span> li;
}						</pre>
						<p>Na função main, devemos definir um ponteiro do tipo Lista. Ele irá receber o endereço do espaço alocado pela função cria_lista( ) e também servirá de parâmetro para as demais funções seguintes.</p>
						<pre>
<span class="blue">int </span>main(){
    Lista *li = cria_lista();
	 <span class="com">...blocos de chamada de função...</span>
     <span class="green">return</span> <span class="number">0</span>;
}</pre>
			</div>
			
			<div class="row">
				<h3>Lista duplamente encadeada e não ordenada</h3>
					<p align="justify">Como o próprio nome descreve é uma lista duplamente encadeada em que não há qualquer tipo de ordenação em relação aos nós pertencentes à lista.  A disposição dos mesmos dependerá da ordem e local (início ou fim da lista) em que forem inseridos.</p>
					<p>Para este tipo de lista realizaremos 6 operações:</p>
					<ul style="list-style-type:circle">
							<li>Inserção no início da lista;</li>
							<li>Inserção no fim da lista;</li>
							<li>Impressão da lista do ínicio ao fim;</li>
							<li>Impressão da lista do fim ao início;</li>
							<li>Remoção de elemento da lista;</li>
							<li>Esvaziar lista</li>
					</ul>
					<h4>Inserção no início da lista</h4>
					<p>Esta é a implementação da função que utilizaremos para inserir um dado no início da lista.</p>
					<pre>
<span class="blue">void</span> insere_inicio_lista(Lista *li){
    <span class="com">/*a cada inserção alocamos dinamicamente um espaço para um novo nó*/</span>
    No *novo =(No*) malloc(<span class="green">sizeof</span>(No));
    <span class="com">/*o número a ser inserido será armazenado em novo->num*/</span>
    printf(<span class="text">"Digite o numero a ser inserido no inicio da lista: "</span>);
    scanf(<span class="text">"%d"</span>,&novo->num);
   <span class="com"> /*caso a lista estiver vazia o primeiro elemento a ser inserido será o primeiro e último elemento da lista*/</span>
    <span class="green">if</span>(li->inicio == <span class="green">NULL</span>){
        li->inicio = novo; <span class="com">/*aqui fazemos com que inicio aponte para o mesmo endereço que novo aponta*/</span>
        li->fim = novo; <span class="com">/*aqui fazemos com que fim aponte para o mesmo endereço que novo aponta*/</span>
        <span class="com">/*como será o único elemento da lista, novo->prox e novo->ant apontam para null*/</span>
        novo->prox = <span class="green">NULL</span>;
        novo->ant = <span class="green">NULL</span>;
    <span class="com">/*caso a lista não esteja vazia*/</span>
    }<span class="green">else</span>{
        <span class="com">/*como a inserção é no inicio, o novo nó inserido receberá no atributo prox (seu ponteiro que aponta para o próximo nó)
         o endereço que inicio aponta*/</span>
        novo->prox =  li->inicio;
        <span class="com">/*inicio no atributo ant recebe o endereço de novo, aqui ainda inicio não foi alterado, portanto essa linha é necessária
           para que quando for o segundo  da lista este elemento possa apontar (através de ant) para o novo elemento que se
           tornará o novo inicio*/</span>
         li->inicio->ant = novo;
       <span class="com"> /*novo no atributo ant recebe null, como depois se tornará o primeiro elemento da lista, seu ponteiro que aponta para o
           nó anterior será null*/</span>
        novo->ant = <span class="green">NULL</span>;
        <span class="com">/*aqui inicio apontará para o novo nó inserido*/</span>
         li->inicio = novo;
    }
    printf(<span class="text">"\nNumero inserido na lista!"</span>);
    getch();
}</pre>
					<p>Na prática isso aconteceria da seguinte maneira:</p>
					<p>Inicialmente temos os ponteiros inicio e fim apontados para null: </p>
					<div class="row"><center><img class="img-responsive " src="img/list/inicio_lista.PNG" alt="" align="middle"><center></div>
					<p>Agora inseriremos o número 8 no início da lista.</p>
					<div class="row"><center><img class="img-responsive " src="img/list/insere_deno1.PNG" alt="" align="middle"><center></div>
					<p>Depois vamos inserir o número 9 no início da lista.</p>
					<div class="row"><center><img class="img-responsive " src="img/list/insere_deno2.PNG" alt="" align="middle"><center></div>
					
					<h4>Inserção no fim da lista</h4>
					<p>Agora trataremos de inserir dados no fim da lista. Vejamos a implementação:</p>
					<pre>
<span class="blue">void</span> insere_fim_lista(Lista *li){
    <span class="com">/*a cada inserção alocamos dinamicamente um espaço para um novo nó*/</span>
    No *novo =(No*) malloc(<span class="green">sizeof</span>(No));
    <span class="com">/*o número a ser inserido será armazenado em novo->num*/</span>
    printf(<span class="text">"Digite o numero a ser inserido no fim da lista: "</span>);
    scanf(<span class="text">"%d</span>,&novo->num);
    <span class="com">/*caso a lista estiver vazia o primeiro elemento a ser inserido será o primeiro e último elemento da lista*/</span>
    <span class="green">if</span>( li->inicio == <span class="green">NULL</span>){
        li->inicio = novo; <span class="com">/*aqui fazemos com que inicio aponte para o mesmo endereço que novo aponta*/</span>
        li->fim = novo; <span class="com">/*aqui fazemos com que fim aponte para o mesmo endereço que novo aponta*/</span>
        <span class="com">/*como será o único elemento da lista, novo->prox e novo->ant apontam para null*/</span>
        novo->prox = <span class="green">NULL</span>;
        novo->ant = <span class="green">NULL</span>;
    }<span class="green">else</span>{
        <span class="com">/*fim no atributo prox recebe o endereço de novo, aqui ainda fim não foi alterado, portanto essa linha é necessária para
        quando esse elemento vier a ser o penultimo da lista possa apontar para o novo elemento que se tonará o novo fim*/</span>
        li->fim->prox = novo;
        <span class="com">/*como a inserção é no fim, o novo nó inserido receberá no atributo ant(seu ponteiro que aponta para o nó anterior) o
           atual endereço que fim aponta*/</span>
        novo->ant =  li->fim;
        <span class="com">/*como será o ultimo elemento da lista, novo no atributo prox apontará para null*/</span>
        novo->prox = <span class="green">NULL</span>;
        <span class="com">/*fim aponta para o novo nó inserido*/</span>
        li->fim = novo;
    }
    printf(<span class="text">"\nNumero inserido na lista!"</span>);
    getch();
}</pre>
					<p>Complementando a lista iniciada anteriormente, vamos inserir o número 3 no final da lista:</p>
					<div class="row"><center><img class="img-responsive " src="img/list/insere_deno3.PNG" alt="" align="middle"><center></div>
					<p>Por fim, vamos inserir o número 5 no final da lista:</p>
					<div class="row"><center><img class="img-responsive " src="img/list/insere_deno4.PNG" alt="" align="middle"><center></div>
					
					<h4>Impressão da lista do início ao fim</h4>
					<p>Para imprimir os elementos da lista (do início para o fim), utilizaremos a seguinte função: </p>
					<pre>
<span class="blue">void</span> imprime_lista_inicio_ao_fim(Lista *li){
    <span class="com">/*caso a lista esteja vazia*/</span>
    <span class="green">if</span>( li->inicio == <span class="green">NULL</span>){
        printf(<span class="text">"\nLista Vazia!!"</span>);
    <span class="com">/*caso a lista não esteja vazia*/</span>
    }<span class="green">else</span>{
        <span class="com">/*utilizando o ponteiro aux,  fazemos com ele aponte para o mesmo endereço que inicio aponta*/</span>
        aux =  li->inicio;
        <span class="green">do</span>{
            <span class="com">/*impressão do elemento que aux aponta*/</span>
            printf(<span class="text">" %d "</span>, aux->num);
            <span class="com">/*aux aponta para o próximo elemento da lista, que será o endereço contido no ponteiro prox.*/</span>
            aux = aux->prox;
            <span class="com">/*essa operação será feita até aux ser diferente de NULL, ou seja, não houverem mais elementos
             a serem impressos*/</span>
        }<span class="green">while</span>(aux != <span class="green">NULL</span>);
    }
    getch();
}</pre>
					<p>A saída seria: 9   8   3   5.</p>
					<h4>Impressão da lista do fim ao início</h4>
					<p>Para imprimir os elementos da lista (do fim para o início), utilizaremos a seguinte função: </p>
					<pre>
<span class="blue">void</span> imprime_lista_fim_ao_inicio(Lista *li){
    <span class="com">/*caso a lista esteja vazia*/</span>
    <span class="green">if</span>( li->inicio == <span class="green">NULL</span>){
        printf(<span class="text">"\nLista Vazia!!"</span>);
    <span class="com">/*caso a lista não esteja vazia*/</span>
    }<span class="green">else</span>{
        <span class="com">/*utilizando o ponteiro aux,  fazemos com ele aponte para o mesmo endereço que fim aponta*/</span>
        aux =  li->fim;
        <span class="green">do</span>{
            <span class="com">/*impressão do elemento que aux aponta*/</span>
            printf(<span class="text">" %d "</span>, aux->num);
            <span class="com">/*aux aponta para o elemento anterior da lista, que será o endereço contido no ponteiro ant.*/</span>
            aux = aux->ant;
            <span class="com">/*essa operação será feita até aux ser diferente de NULL, ou seja, não houverem mais elementos
                a serem impressos*/</span>
        }<span class="green">while</span>(aux !=<span class="green"> NULL</span>);
    }
    getch();
}</pre>
					<p>A saída seria: 5   3   8   9.</p>
					<h4>Remoção de elemento da lista</h4>
					<p>Para removermos um determinado elemento da lista, utilizaremos a seguinte função:</p>
					<pre>
<span class="blue">void</span> remover_elemento(Lista *li){
    <span class="blue">int</span> numero, achou; <span class="com">/*a variável achou será utilizada como um contador de números removidos*/</span>
    <span class="green">if</span>(li->inicio == <span class="green">NULL</span>){ <span class="com">/*caso a lista esteja vazia*/</span>
        printf(<span class="text">"\nLista Vazia!!"</span>);
    }<span class="green">else</span>{  <span class="com">/*caso a lista não esteja vazia*/</span>
        printf(<span class="text">"Digite o elemento a ser removido: "</span>); 
		scanf(<span class="text">"%d"</span>, &numero);
        aux =  li->inicio; <span class="com">/*utilizando o ponteiro aux,  fazemos com ele aponte para o mesmo endereço que inicio aponta*/</span>
        achou = <span class="number">0</span>;
        <span class="green">do</span>{
            <span class="green">if</span>(aux->num == numero){ <span class="com">/*caso aux-> num seja igual ao número a ser removido*/</span>
                achou = achou + <span class="number">1</span>; <span class="com">/*incrementamos achou*/</span>
                <span class="green">if</span>(aux ==  li->inicio){ <span class="com">/*se o elemento a ser removido for o primeiro da lista*/</span>
                    li->inicio = aux ->prox; <span class="com">/*inicio apontará para o segundo elemento da lista ou para NULL caso o elemento
                                                            removido seja o único elemento da lista*/</span>
                    <span class="green">if</span>( li->inicio != <span class="green">NULL</span>){ <span class="com">/*caso inicio tenha não recebido null na linha anterior*/</span>
                         li->inicio->ant = <span class="green">NULL</span>; <span class="com">/*ant de inicio também apontará para null*/</span>
                    }
                    free(aux); <span class="com"> /*desalocamos o espaço para onde aux apontava*/</span>
                    aux =  li->inicio; <span class="com">/*aux aponta para o inicio da lista*/</span>
                }<span class="green">else if</span>(aux == li->fim){ <span class="com">/*se o elemento a ser removido for o ultimo da lista*/</span>
                                li->fim =  li->fim->ant; <span class="com">/*fim apontará para o elemento anterior a ele*/</span>
                                li->fim->prox = <span class="green">NULL</span>; <span class="com">/*fim no atributo prox apontará para null*/</span>
                                free(aux); <span class="com">/*desalocamos o espaço para onde aux apontava*/</span>
                                aux = <span class="green">NULL</span>; <span class="com">/*como era o últmo elemento da lista, aux recebe NULL*/</span>
                        }<span class="green">else</span>{ <span class="com">/*se o elemento a ser removido não for nem o primeiro nem o último da lista */</span>
                                aux->ant->prox = aux->prox; <span class="com">/*o elemento anterior ao que iremos remover, em prox, apontara para
                                                                                   o endereço do próximo elemento depois de aux */</span>
                                aux->prox->ant = aux->ant;  <span class="com">/*o elemento seguinte ao que iremos remover, em ant,  apontará para
                                                                                  o endereço do elemento anterior a aux */</span>
                                aux2 = aux->prox; <span class="com">/*aux2 aponta para o elemento depois de aux*/</span>
                                free(aux); <span class="com">/*desalocamos o espaço para onde aux apontava*/</span>
                                aux = aux2; <span class="com">/*aux aponta para onde aux2 apontava*/</span>
                        }
        }<span class="green">else</span>{ <span class="com">/*caso aux-> num não seja igual ao número a ser removido*/</span>
                    aux = aux -> prox; <span class="com">/*aux aponta para o próximo elemento da lista*/</span>
        }
        <span class="com">/*essa operação será feita até aux ser diferente de NULL, ou seja, não houverem mais elementos a serem pesquisados*/</span>
        }<span class="green">while</span>(aux != <span class="green">NULL</span>);

                <span class="com">/*impressão do resultado*/</span>
                <span class="green">if</span>(achou ==  <span class="number">0</span>){
                    printf(<span class="text">"Numero nao encontrado!"</span>);
                }<span class="green">else</span>{
                    printf(<span class="text">"Numero removido %d vez(es)"</span>,achou);
                }

    }
    getch();
}</pre>
					<p>Com base na lista criada anteriormente, faremos algumas remoções: </p>
					<div class="row"><center><img class="img-responsive " src="img/list/insere_deno4.PNG" alt="" align="middle"><center></div>
					<p>Primeiramente, vamos remover o número 9:</p>
					<div class="row"><center><img class="img-responsive " src="img/list/remove_deno1.PNG" alt="" align="middle"><center></div>
					<p>Vamos então remover o número 3:</p>
					<div class="row"><center><img class="img-responsive " src="img/list/remove_deno2.PNG" alt="" align="middle"><center></div>
					<p>Por fim removeremos o número 8.</p>
					<div class="row"><center><img class="img-responsive " src="img/list/remove_deno3.PNG" alt="" align="middle"><center></div>
					<h4>Esvaziar lista</h4>
					<p>Nesta última operação esvaziaremos a nossa lista, isto significa remover todos os seus nós restantes desalocando o espaço reservado para cada um. Esta é a implementação utilizada:</p>
					<pre>
<span class="blue">void</span> esvaziar_lista(Lista *li){
    <span class="com">/*caso a lista esteja vazia*/</span>
    <span class="green">if</span>(li->inicio == <span class="green">NULL</span>){
        printf(<span class="text">"\nLista Vazia!!"</span>);
    <span class="com">/*caso a lista não esteja vazia*/</span>
    }<span class="green">else</span>{
        <span class="com">/*utilizando o ponteiro aux,  fazemos com ele aponte para o mesmo endereço de inicio  aponta*/</span>
        aux = li->inicio;
        <span class="green">do</span>{
            <span class="com">/*inicio apontará para o próximo elemento da lista*/</span>
            li->inicio = li->inicio->prox;
             <span class="com">/*desalocamos o espaço para onde aux apontava*/</span>
            free(aux);
           <span class="com"> /*aux apontará para o mesmo endereço que inicio aponta*/</span>
            aux = li->inicio;
        <span class="com">/*essa operação será feita até aux ser diferente de NULL, ou seja, não houverem mais elementos a serem removidos*/</span>
        }<span class="green">while</span>(aux != <span class="green">NULL</span>);
        printf(<span class="text">"\nLista Esvaziada!!"</span>);
    }
    getch();
}					</pre>
					<p>O resultado final após essa operação seria esse:</p>
					<div class="row"><center><img class="img-responsive " src="img/list/inicio_lista.PNG" alt="" align="middle"><center></div>
				</div>
				<div class="row">
				<h3>Lista duplamente encadeada e ordenada</h3>
					<p align="justify">A diferença desse tipo de lista duplamente encadeada é que ela utiliza determinado dado armazenado como parâmetro para a ordenação da lista. No nosso caso utilizaremos "num" para ordenar nossa lista de maneira crescente.</p>
					<p>Para este tipo de lista realizaremos 5 operações:</p>
					<ul style="list-style-type:circle">
							<li>Inserção na lista;</li>
							<li>Impressão da lista do ínicio ao fim;</li>
							<li>Impressão da lista do fim ao início;</li>
							<li>Remoção de elemento da lista;</li>
							<li>Esvaziar lista</li>
					</ul>
					<h4>Inserção na lista</h4>
					<p>Esta é a implementação da função que utilizaremos para inserir um dado na lista.</p>
					<pre>
<span class="blue">void</span> insere_lista(Lista *li){
    No *novo =(No*) malloc(<span class="green">sizeof</span>(No)); <span class="com">/*a cada inserção alocamos dinamicamente um espaço para um novo nó*/</span>
    <span class="com">/*o número a ser inserido será armazenado em novo->num*/</span>
    printf(<span class="text">"Digite o numero a ser inserido na lista: "</span>); 
	scanf(<span class="text">"%d"</span>,&novo->num);
    <span class="green">if</span>(li->inicio == <span class="green">NULL</span>){ <span class="com">/*caso a lista estiver vazia o elemento a ser inserido será o primeiro e último elemento da lista*/</span>
        <span class="com">/*como será o único elemento da lista, novo->prox e novo->ant apontam para null*/</span>
        novo->prox = <span class="green">NULL</span>;
        novo->ant = <span class="green">NULL</span>;
        li->inicio = novo;<span class="com"> /*aqui fazemos com que inicio aponte para o mesmo endereço que novo aponta*/</span>
        li->fim = novo; <span class="com">/*aqui fazemos com que fim aponte para o mesmo endereço que novo aponta*/</span>
    }<span class="green">else</span>{ <span class="com">/*caso a lista não esteja vazia*/</span>
        aux = li->inicio; <span class="com">/*aux aponta para o endereço que inicio aponta*/</span>
        <span class="com">/*enquanto ainda houverem elementos na lista e o novo número for maior que aux->num,
         ou seja enquanto não for encontrado um número maior que o número inserido*/</span>
        <span class="green">while</span>(aux != <span class="green">NULL </span>&& novo->num > aux->num){
            aux = aux->prox; <span class="com">/*aux aponta para o próximo elemento da lista*/</span>
             <span class="com">/*isso é feito para encontrar o ponto exato para o número ser inserido*/</span>
        }
        <span class="com">/*caso não existam números maiores ou iguais ao novo número , ele será inserido no início da lista*/</span>
        <span class="green">if</span>(aux == li->inicio){
            novo->prox = li->inicio; <span class="com">/*novo->prox apontara para o atual inicio, que depois será o segundo elemento*/</span>
            novo->ant = <span class="green">NULL</span>; <span class="com">/*como novo será o primeiro da lista, seu ponteiro ant deverá apontar para null*/</span>
            li->inicio->ant = novo; <span class="com">/*o inicio atual(que depois será o segunda da lista) em ant, apontara para o endereço de novo*/</span>
            li->inicio = novo; <span class="com">/*inicio aponta para novo*/</span>
        <span class="com">/*caso todos elementos da lista sejam menores que o número a ser inserido, ele será inserido no fim*/</span>
        }<span class="green">else if</span>(aux == <span class="green">NULL</span>){
            li->fim->prox = novo; <span class="com">/*o fim atual (que depois será o penultimo da lista) em prox, apontará para novo*/</span>
            novo->ant = li->fim; <span class="com">/*novo -> ant aponta para o endereço do fim atual.*/</span>
            li->fim = novo; <span class="com">/*fim aponta para novo*/</span>
            li->fim->prox = <span class="green">NULL</span>; <span class="com">/*todo ultimo elemento da lista  em prox aponta para null*/</span>
        }<span class="green">else</span>{  <span class="com">/*caso novo seja inserido no meio da lista, ele será inserido antes de aux*/</span>
            novo->prox = aux; <span class="com">/*novo será inserido antes do aux atual, então novo->prox aponta para o aux atual*/</span>
            aux->ant->prox = novo; <span class="com">/*o número que estava antes de aux em prox aponta para novo*/</span>
            novo->ant = aux->ant; <span class="com">/*novo-> ant aponta para o nó anterior a aux atual*/</span>
            aux->ant = novo; <span class="com">/*aux atual será o elemento seguinte a novo, portanto em ant apontará para novo*/</span>
        }
    }
    printf(<span class="text">"\nNumero inserido na lista!"</span>);
    getch();
}		</pre>
					<p>Na prática isso aconteceria da seguinte maneira:</p>
					<p>Inicialmente temos os ponteiros inicio e fim apontados para null: </p>
					<div class="row"><center><img class="img-responsive " src="img/list/inicio_lista.PNG" alt="" align="middle"><center></div>
					<p>Primeiro: inseriremos o número 5 na lista.</p>
					<div class="row"><center><img class="img-responsive " src="img/list/insere_deo1.PNG" alt="" align="middle"><center></div>
					<p>Segundo: vamos inserir o número 9 na lista.</p>
					<div class="row"><center><img class="img-responsive " src="img/list/insere_deo2.PNG" alt="" align="middle"><center></div>
					<p>Terceiro: vamos inserir o número 2 na lista:</p>
					<div class="row"><center><img class="img-responsive " src="img/list/insere_deo3.PNG" alt="" align="middle"><center></div>
					<p>Por fim, vamos inserir o número 7 na lista:</p>
					<div class="row"><center><img class="img-responsive " src="img/list/insere_deo4.PNG" alt="" align="middle"><center></div>
					
					<h4>Impressão da lista do início ao fim</h4>
					<p>Para imprimir os elementos da lista (do início para o fim), utilizaremos a seguinte função: </p>
					<pre>
<span class="blue">void</span> imprime_lista_inicio_ao_fim(Lista *li){
    <span class="com">/*caso a lista esteja vazia*/</span>
    <span class="green">if</span>( li->inicio == <span class="green">NULL</span>){
        printf(<span class="text">"\nLista Vazia!!"</span>);
    <span class="com">/*caso a lista não esteja vazia*/</span>
    }<span class="green">else</span>{
        <span class="com">/*utilizando o ponteiro aux,  fazemos com ele aponte para o mesmo endereço que inicio aponta*/</span>
        aux =  li->inicio;
        <span class="green">do</span>{
            <span class="com">/*impressão do elemento que aux aponta*/</span>
            printf(<span class="text">" %d "</span>, aux->num);
            <span class="com">/*aux aponta para o próximo elemento da lista, que será o endereço contido no ponteiro prox.*/</span>
            aux = aux->prox;
            <span class="com">/*essa operação será feita até aux ser diferente de NULL, ou seja, não houverem mais elementos
             a serem impressos*/</span>
        }<span class="green">while</span>(aux != <span class="green">NULL</span>);
    }
    getch();
}</pre>
					<p>A saída seria: 2   5   7   9.</p>
					<h4>Impressão da lista do fim ao início</h4>
					<p>Para imprimir os elementos da lista (do fim para o início), utilizaremos a seguinte função: </p>
					<pre>
<span class="blue">void</span> imprime_lista_fim_ao_inicio(Lista *li){
    <span class="com">/*caso a lista esteja vazia*/</span>
    <span class="green">if</span>( li->inicio == <span class="green">NULL</span>){
        printf(<span class="text">"\nLista Vazia!!"</span>);
    <span class="com">/*caso a lista não esteja vazia*/</span>
    }<span class="green">else</span>{
        <span class="com">/*utilizando o ponteiro aux,  fazemos com ele aponte para o mesmo endereço que fim aponta*/</span>
        aux =  li->fim;
        <span class="green">do</span>{
            <span class="com">/*impressão do elemento que aux aponta*/</span>
            printf(<span class="text">" %d "</span>, aux->num);
            <span class="com">/*aux aponta para o elemento anterior da lista, que será o endereço contido no ponteiro ant.*/</span>
            aux = aux->ant;
            <span class="com">/*essa operação será feita até aux ser diferente de NULL, ou seja, não houverem mais elementos
                a serem impressos*/</span>
        }<span class="green">while</span>(aux !=<span class="green"> NULL</span>);
    }
    getch();
}</pre>
					<p>A saída seria: 9   7   5   2.</p>
					<h4>Remoção de elemento da lista</h4>
					<p>Para removermos um determinado elemento da lista, utilizaremos a seguinte função:</p>
					<pre>
<span class="blue">void</span> remover_elemento(Lista *li){
    <span class="blue">int</span> numero, achou; <span class="com">/*a variável achou será utilizada como um contador de números removidos*/</span>
    <span class="green">if</span>(li->inicio == <span class="green">NULL</span>){ <span class="com">/*caso a lista esteja vazia*/</span>
        printf(<span class="text">"\nLista Vazia!!"</span>);
    }<span class="green">else</span>{  <span class="com">/*caso a lista não esteja vazia*/</span>
        printf(<span class="text">"Digite o elemento a ser removido: "</span>); 
		scanf(<span class="text">"%d"</span>, &numero);
        aux =  li->inicio; <span class="com">/*utilizando o ponteiro aux,  fazemos com ele aponte para o mesmo endereço que inicio aponta*/</span>
        achou = <span class="number">0</span>;
        <span class="green">do</span>{
            <span class="green">if</span>(aux->num == numero){ <span class="com">/*caso aux-> num seja igual ao número a ser removido*/</span>
                achou = achou + <span class="number">1</span>; <span class="com">/*incrementamos achou*/</span>
                <span class="green">if</span>(aux ==  li->inicio){ <span class="com">/*se o elemento a ser removido for o primeiro da lista*/</span>
                    li->inicio = aux ->prox; <span class="com">/*inicio apontará para o segundo elemento da lista ou para NULL caso o elemento
                                                            removido seja o único elemento da lista*/</span>
                    <span class="green">if</span>( li->inicio != <span class="green">NULL</span>){ <span class="com">/*caso inicio tenha não recebido null na linha anterior*/</span>
                         li->inicio->ant = <span class="green">NULL</span>; <span class="com">/*ant de inicio também apontará para null*/</span>
                    }
                    free(aux); <span class="com"> /*desalocamos o espaço para onde aux apontava*/</span>
                    aux =  li->inicio; <span class="com">/*aux aponta para o inicio da lista*/</span>
                }<span class="green">else if</span>(aux == li->fim){ <span class="com">/*se o elemento a ser removido for o ultimo da lista*/</span>
                                li->fim =  li->fim->ant; <span class="com">/*fim apontará para o elemento anterior a ele*/</span>
                                li->fim->prox = <span class="green">NULL</span>; <span class="com">/*fim no atributo prox apontará para null*/</span>
                                free(aux); <span class="com">/*desalocamos o espaço para onde aux apontava*/</span>
                                aux = <span class="green">NULL</span>; <span class="com">/*como era o últmo elemento da lista, aux recebe NULL*/</span>
                        }<span class="green">else</span>{ <span class="com">/*se o elemento a ser removido não for nem o primeiro nem o último da lista */</span>
                                aux->ant->prox = aux->prox; <span class="com">/*o elemento anterior ao que iremos remover, em prox, apontara para
                                                                                   o endereço do próximo elemento depois de aux */</span>
                                aux->prox->ant = aux->ant;  <span class="com">/*o elemento seguinte ao que iremos remover, em ant,  apontará para
                                                                                  o endereço do elemento anterior a aux */</span>
                                aux2 = aux->prox; <span class="com">/*aux2 aponta para o elemento depois de aux*/</span>
                                free(aux); <span class="com">/*desalocamos o espaço para onde aux apontava*/</span>
                                aux = aux2; <span class="com">/*aux aponta para onde aux2 apontava*/</span>
                        }
        }<span class="green">else</span>{ <span class="com">/*caso aux-> num não seja igual ao número a ser removido*/</span>
                    aux = aux -> prox; <span class="com">/*aux aponta para o próximo elemento da lista*/</span>
        }
        <span class="com">/*essa operação será feita até aux ser diferente de NULL, ou seja, não houverem mais elementos a serem pesquisados*/</span>
        }<span class="green">while</span>(aux != <span class="green">NULL</span>);

                <span class="com">/*impressão do resultado*/</span>
                <span class="green">if</span>(achou ==  <span class="number">0</span>){
                    printf(<span class="text">"Numero nao encontrado!"</span>);
                }<span class="green">else</span>{
                    printf(<span class="text">"Numero removido %d vez(es)"</span>,achou);
                }

    }
    getch();
}</pre>
					<p>Com base na lista criada anteriormente, faremos algumas remoções: </p>
					<div class="row"><center><img class="img-responsive " src="img/list/insere_deo4.PNG" alt="" align="middle"><center></div>
					<p>Primeiramente, vamos remover o número 5 da nossa lista:</p>
					<div class="row"><center><img class="img-responsive " src="img/list/remove_deo1.PNG" alt="" align="middle"><center></div>
					<p>Depois removeremos o número 9.</p>
					<div class="row"><center><img class="img-responsive " src="img/list/remove_deo2.PNG" alt="" align="middle"><center></div>
					<p>E por fim removeremos o número 2.</p>
					<div class="row"><center><img class="img-responsive " src="img/list/remove_deo3.PNG" alt="" align="middle"><center></div>
					<h4>Esvaziar lista</h4>
					<p>Nesta última operação esvaziaremos a nossa lista, isto significa remover todos os seus nós restantes desalocando o espaço reservado para cada um. Esta é a implementação utilizada:</p>
					<pre>
<span class="blue">void</span> esvaziar_lista(Lista *li){
    <span class="com">/*caso a lista esteja vazia*/</span>
    <span class="green">if</span>(li->inicio == <span class="green">NULL</span>){
        printf(<span class="text">"\nLista Vazia!!"</span>);
    <span class="com">/*caso a lista não esteja vazia*/</span>
    }<span class="green">else</span>{
        <span class="com">/*utilizando o ponteiro aux,  fazemos com ele aponte para o mesmo endereço de inicio  aponta*/</span>
        aux = li->inicio;
        <span class="green">do</span>{
            <span class="com">/*inicio apontará para o próximo elemento da lista*/</span>
            li->inicio = li->inicio->prox;
             <span class="com">/*desalocamos o espaço para onde aux apontava*/</span>
            free(aux);
           <span class="com"> /*aux apontará para o mesmo endereço que inicio aponta*/</span>
            aux = li->inicio;
        <span class="com">/*essa operação será feita até aux ser diferente de NULL, ou seja, não houverem mais elementos a serem removidos*/</span>
        }<span class="green">while</span>(aux != <span class="green">NULL</span>);
        printf(<span class="text">"\nLista Esvaziada!!"</span>);
    }
    getch();
}			</pre>
					<p>O resultado final após essa operação seria esse:</p>
					<div class="row"><center><img class="img-responsive " src="img/list/inicio_lista.PNG" alt="" align="middle"><center></div>
				</div>
				<center>
				<h3>Video Explicativo - Listas Duplamente Encadeadas</h3>
					<p>                                      </p>
					<video width=80% height="315" class="img-responsive" controls>
					  <source src="video/listas_de.mp4" type="video/mp4">
					  <source src="movie.ogg" type="video/ogg">
					  Your browser does not support the video tag.
					</video>
				</center>
				<div class="row">
					<h3>Listas Circulares</h3>
						<p align="justify">As listas citadas anteriormente também podem ser implementadas de forma circular. Isso significa que, quando forem simplesmente encadeadas seu ponteiro próximo “*prox” do último elemento apontará para o primeiro elemento da lista. Já quando forem duplamente encadeadas terão além do ponteiro próximo “*prox” do último elemento apontando para o primeiro elemento da lista, o ponteiro anterior “*ant” do primeiro elemento apontará para o último elemento da lista.</p>
						<ul style="list-style-type:circle">
							<b><center><li>Lista circular simplesmente encadeada e não ordenada</li></center></b>
							<div class="row"><center><img class="img-responsive " src="img/list/circular_seno.PNG" alt="" align="middle"><center></div>
							<b><center><li>Lista circular simplesmente encadeada e ordenada</li></center></b>
							<div class="row"><center><img class="img-responsive " src="img/list/circular_seo.PNG" alt="" align="middle"><center></div>
							<b><center><li>Lista circular duplamente encadeada e não ordenada.</li></center></b>
							<div class="row"><center><img class="img-responsive " src="img/list/circular_deno.PNG" alt="" align="middle"><center></div>
							<b><center><li>Lista circular duplamente encadeada e ordenada.</li></center></b>
							<div class="row"><center><img class="img-responsive " src="img/list/circular_deo.PNG" alt="" align="middle"><center></div>
					     </ul>
			</div>
				
				
			
			
					
			<!-- /.col-lg-4 -->
			
			</div>
				
		</div>
	</div>
	<div id="ex" class="content-section-b" style="border-top: 0">
		<div class="container">

			<div class="col-md-6 col-md-offset-3 text-center wrap_title">
				<h2>Exercícios</h2>
			</div>
			<center>
			<div class="row">
	
				<div class="col-sm-4 col-sm-offset-4 wow fadeInDown text-center">
					<a href="exercicios/lista13.pdf">
					  <img class="rotate" src="img/icon/pdf.png" alt="Generic placeholder image">
					  <h3>Download</h3>
					  <center><p text-align: center>Dowload lista de exercícios para treinamento de Listas</p></center>
					</a>
				  <!-- <p><a class="btn btn-embossed btn-primary view" role="button">View Details</a></p> -->
				</div><!-- /.col-lg-4 -->
				
			</div><!-- /.row -->
			
			
		</div>
	</div>
	
	
	
	<footer>
      <div class="container">
        <div class="row">
          <div class="col-md-7">
            <h3 class="footer-title">REA-AED</h3>
            <p>Desenvolvido por Gabriel Bueno da Silva<br>
			<p>Contato: gabrielbuenodasilva@yahoo.com.br</p>
			
			<!-- LICENSE -->
			<p>Utilização do tema:</p>
			<a rel="cc:attributionURL" href="http://www.andreagalanti.it/flatfy"
		   property="dc:title">Flatfy Theme </a> by
		   <a rel="dc:creator" href="http://www.andreagalanti.it"
		   property="cc:attributionName">Andrea Galanti</a>
		   is licensed to the public under 
		   <BR>the <a rel="license"
		   href="http://creativecommons.org/licenses/by-nc/3.0/it/deed.it">Creative
		   Commons Attribution 3.0 License - NOT COMMERCIAL</a>.
		   
	   
          </div> <!-- /col-xs-7 -->

          <div class="col-md-5">
            <div class="footer-banner">
            </div>
          </div>
        </div>
      </div>
    </footer>

    <!-- JavaScript -->
    <script src="js/jquery-1.10.2.js"></script>
    <script src="js/bootstrap.js"></script>
	<script src="js/owl.carousel.js"></script>
	<script src="js/script.js"></script>
	<!-- StikyMenu -->
	<script src="js/stickUp.min.js"></script>
	<script type="text/javascript">
	  jQuery(function($) {
		$(document).ready( function() {
		  $('.navbar-default').stickUp();
		  
		});
	  });
	
	</script>
	<!-- Smoothscroll -->
	<script type="text/javascript" src="js/jquery.corner.js"></script> 
	<script src="js/wow.min.js"></script>
	<script>
	 new WOW().init();
	</script>
	<script src="js/classie.js"></script>
	<script src="js/uiMorphingButton_inflow.js"></script>
	<!-- Magnific Popup core JS file -->
	<script src="js/jquery.magnific-popup.js"></script> 
</body>

</html>
